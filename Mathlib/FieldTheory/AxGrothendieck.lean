/-
Copyright (c) 2023 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes
-/

import Mathlib.RingTheory.Algebraic
import Mathlib.Data.Fintype.Card
import Mathlib.ModelTheory.Algebra.Field.AlgClosed
import Mathlib.ModelTheory.Algebra.Ring.MvPolynomial

#align_import field_theory.ax_grothendieck from "leanprover-community/mathlib"@"4e529b03dd62b7b7d13806c3fb974d9d4848910e"

/-!
# Ax-Grothendieck

This file proves that if `K` is an algebraically closed field,
then any injective polynomial map `K^n → K^n` is also surjective.

## Main results

* `ax_grothendieck`: any injective polynomial map `K^n → K^n` is also surjective
whenever `K` is an algebraically closed field.
* `ax_grothendieck_of_locally_finite`: any injective polynomial map `R^n → R^n` is also surjective
whenever `R` is an algebraic extension of a finite field.

## TODO

Generalize to polynomial maps from a definable set to itself.

-/


noncomputable section

open MvPolynomial Finset Function

/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/
theorem ax_grothendieck_of_locally_finite {ι K R : Type*} [Field K] [Finite K] [CommRing R]
    [Finite ι] [Algebra K R] (alg : Algebra.IsAlgebraic K R) (ps : ι → MvPolynomial ι R)
    (hinj : Injective fun v i => MvPolynomial.eval v (ps i)) :
    Surjective fun v i => MvPolynomial.eval v (ps i) := by
  have is_int : ∀ x : R, IsIntegral K x := fun x => isAlgebraic_iff_isIntegral.1 (alg x)
  classical
    intro v
    cases nonempty_fintype ι
    /- `s` is the set of all coefficients of the polynomial, as well as all of
      the coordinates of `v`, the point I am trying to find the preimage of. -/
    let s : Finset R :=
      (Finset.biUnion (univ : Finset ι) fun i => (ps i).support.image fun x => coeff x (ps i)) ∪
        (univ : Finset ι).image v
    have hv : ∀ i, v i ∈ Algebra.adjoin K (s : Set R) := fun j =>
      Algebra.subset_adjoin (mem_union_right _ (mem_image.2 ⟨j, mem_univ _, rfl⟩))
    have hs₁ : ∀ (i : ι) (k : ι →₀ ℕ),
        k ∈ (ps i).support → coeff k (ps i) ∈ Algebra.adjoin K (s : Set R) :=
      fun i k hk => Algebra.subset_adjoin
        (mem_union_left _ (mem_biUnion.2 ⟨i, mem_univ _, mem_image_of_mem _ hk⟩))
    letI := isNoetherian_adjoin_finset s fun x _ => is_int x
    letI := Module.IsNoetherian.finite K (Algebra.adjoin K (s : Set R))
    letI : Finite (Algebra.adjoin K (s : Set R)) :=
      FiniteDimensional.finite_of_finite K (Algebra.adjoin K (s : Set R))
    -- The restriction of the polynomial map, `ps`, to the subalgebra generated by `s`
    let res : (ι → Algebra.adjoin K (s : Set R)) → ι → Algebra.adjoin K (s : Set R) := fun x i =>
      ⟨eval (fun j : ι => (x j : R)) (ps i), eval_mem (hs₁ _) fun i => (x i).2⟩
    have hres_inj : Injective res := by
      intro x y hxy
      ext i
      simp only [Subtype.ext_iff, funext_iff] at hxy
      exact congr_fun (hinj (funext hxy)) i
    have hres_surj : Surjective res := Finite.injective_iff_surjective.1 hres_inj
    cases' hres_surj fun i => ⟨v i, hv i⟩ with w hw
    use fun i => w i
    simpa only [Subtype.ext_iff, funext_iff] using hw
#align ax_grothendieck_of_locally_finite ax_grothendieck_of_locally_finite

end

namespace FirstOrder

open MvPolynomial FreeCommRing Language Field Ring

/-- The collection of first order formulas corresponding to the Ax-Grothendieck theorem. -/
noncomputable def genericPolyMapSurjectiveOfInjective {ι : Type*} [Fintype ι]
    (mons : ι → Finset (ι →₀ ℕ)) : Language.ring.Sentence :=
  let l1 : List (Language.ring.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι))) :=
    (Finset.univ : Finset ι).toList.map (fun i =>
      (termOfFreeCommRing (genericPolyMap mons i)).relabel
        (Sum.inl ∘ Sum.map id (fun i => (0, i)))
    =' (termOfFreeCommRing (genericPolyMap mons i)).relabel
        (Sum.inl ∘ Sum.map id (fun i => (1, i))))
  let f1 : Language.ring.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι)) :=
    l1.foldr (. ⊓ .) ⊤
  let l2 : List (Language.ring.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι))) :=
    (Finset.univ : Finset ι).toList.map  (fun i =>
      .var (Sum.inl (Sum.inr (0, i))) =' .var (Sum.inl (Sum.inr (1, i))))
  let f2 : Language.ring.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι)) :=
    l2.foldr (. ⊓ .) ⊤
  let inj : Language.ring.Formula (Σ i : ι, mons i) :=
    Formula.iAlls (γ := Fin 2 × ι) id (f1 ⟹ f2)
  let l3 : List (Language.ring.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι))) :=
    (Finset.univ : Finset ι).toList.map  (fun i =>
      (termOfFreeCommRing (genericPolyMap mons i)).relabel
        (Sum.inl ∘ Sum.map id (fun i => (0, i))) ='
      .var (Sum.inl (Sum.inr (1, i))))
  let f3 : Language.ring.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι)) :=
    l3.foldr (. ⊓ .) ⊤
  let surj : Language.ring.Formula (Σ i : ι, mons i) :=
    Formula.iAlls (γ := ι) id
      (Formula.iExs (γ := ι)
        (fun (i : (Σ i : ι, mons i) ⊕ (Fin 2 × ι)) =>
          show ((Σ i : ι, mons i) ⊕ ι) ⊕ ι
          from Sum.elim (Sum.inl ∘ Sum.inl)
            (fun i => if i.1 = 0 then Sum.inr i.2 else (Sum.inl (Sum.inr i.2))) i) f3)
  Formula.iAlls (γ := Σ i : ι, mons i) Sum.inr (inj ⟹ surj)

theorem realize_genericPolyMapSurjectiveOfInjective
    {K : Type*} [Field K] [CompatibleRing K] {ι : Type*} [Fintype ι]
    (mons : ι → Finset (ι →₀ ℕ)) :
    (K ⊨ genericPolyMapSurjectiveOfInjective mons) ↔
      ∀ p : { p : ι → MvPolynomial ι K // (∀ i, (p i).support ⊆ mons i) },
        Function.Injective (fun v i => MvPolynomial.eval v (p.1 i)) →
        Function.Surjective (fun v i => MvPolynomial.eval v (p.1 i)) := by
  letI := Classical.decEq K
  letI := Classical.decEq ι
  rw [Equiv.forall_congr_left' (mvPolynomialSupportLEEquiv mons)]
  simp only [Sentence.Realize, Formula.Realize, genericPolyMapSurjectiveOfInjective, Function.comp,
    Sum.map, id_eq, BoundedFormula.realize_iAlls, Sum.elim_inr, BoundedFormula.realize_imp,
    BoundedFormula.realize_foldr_inf, List.mem_map, Finset.mem_toList, Finset.mem_univ, true_and,
    forall_exists_index, forall_apply_eq_imp_iff', BoundedFormula.realize_bdEqual,
    Term.realize_relabel, Sum.elim_inl, realize_termOfFreeCommRing, lift_genericPolyMap,
    Term.realize_var, Equiv.forall_congr_left' (Equiv.curry (Fin 2) ι K), Equiv.curry_symm_apply,
    Function.uncurry_apply_pair, Fin.forall_fin_succ_pi, Fin.cons_zero, Fin.forall_fin_zero_pi,
    BoundedFormula.realize_iExs, ite_true, one_ne_zero, ite_false, Function.Injective,
    Function.funext_iff, Function.Surjective]
  rfl

theorem ACF_models_genericPolyMapSurjectiveOfInjective_of_prime
    {ι : Type*} [Fintype ι]
    {p : ℕ} (hp : p.Prime) (mons : ι → Finset (ι →₀ ℕ)) :
    Theory.ACF p ⊨ᵇ genericPolyMapSurjectiveOfInjective mons := by
  letI := Classical.decEq ι
  haveI : Fact p.Prime := ⟨hp⟩
  letI := compatibleRingOfRing (AlgebraicClosure (ZMod p))
  haveI : CharP (AlgebraicClosure (ZMod p)) p :=
    charP_of_injective_algebraMap
      (RingHom.injective (algebraMap (ZMod p) (AlgebraicClosure (ZMod p)))) p
  rw [← (ACF_isComplete (Or.inl hp)).realize_sentence_iff _
    (AlgebraicClosure (ZMod p)),
    realize_genericPolyMapSurjectiveOfInjective]
  rintro ⟨f, _⟩
  exact ax_grothendieck_of_locally_finite (K := ZMod p) (ι := ι)
    (IsAlgClosure.algebraic (R := ZMod p) (K := AlgebraicClosure (ZMod p))) f

theorem ACF_models_genericPolyMapSurjectiveOfInjective_of_prime_or_zero
    {ι : Type*} [Fintype ι]
    {p : ℕ} (hp : p.Prime ∨ p = 0) (mons : ι → Finset (ι →₀ ℕ)) :
    Theory.ACF p ⊨ᵇ genericPolyMapSurjectiveOfInjective mons := by
  rcases hp with hp | rfl
  · exact ACF_models_genericPolyMapSurjectiveOfInjective_of_prime hp mons
  · rw [ACF0_realize_iff_infinite_ACF_prime_realize]
    convert Set.infinite_univ (α := Nat.Primes)
    rw [Set.eq_univ_iff_forall]
    intro ⟨p, hp⟩
    exact ACF_models_genericPolyMapSurjectiveOfInjective_of_prime hp mons

end FirstOrder

open Function FirstOrder Language Field

/-- The **Ax-Grothendieck** theorem

Any injective polynomial map `K^n → K^n` is also surjective if `K` is an
algberaically closed field. -/
theorem ax_grothendieck {ι K : Type*} [Finite ι] [Field K]
    [IsAlgClosed K] (ps : ι → MvPolynomial ι K) :
    Injective (fun v i => MvPolynomial.eval v (ps i)) →
    Surjective fun v i => MvPolynomial.eval v (ps i) := by
  letI := Fintype.ofFinite ι
  let p : ℕ := ringChar K
  haveI : CharP K p := ⟨ringChar.spec K⟩
  letI := Ring.compatibleRingOfRing K
  have := ACF_models_genericPolyMapSurjectiveOfInjective_of_prime_or_zero
    (CharP.char_is_prime_or_zero K p) (fun i => (ps i).support)
  rw [← (ACF_isComplete (CharP.char_is_prime_or_zero K p)).realize_sentence_iff _ K,
    realize_genericPolyMapSurjectiveOfInjective] at this
  exact this ⟨ps, fun i => Finset.Subset.refl _⟩
