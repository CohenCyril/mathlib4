/-
Copyright (c) 2023 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes
-/
import Mathlib.Data.MvPolynomial.Basic
import Mathlib.RingTheory.Algebraic
import Mathlib.Data.Fintype.Card
import Mathlib.ModelTheory.Algebra.Field.AlgClosed

#align_import field_theory.ax_grothendieck from "leanprover-community/mathlib"@"4e529b03dd62b7b7d13806c3fb974d9d4848910e"

/-!
# Ax-Grothendieck for algebraic extensions of `ZMod p`

This file proves that if `R` is an algebraic extension of a finite field,
then any injective polynomial map `R^n → R^n` is also surjective.

This proof is required for the true Ax-Grothendieck theorem, which proves the same result
for any algebraically closed field of characteristic zero.

## TODO

The proof of the theorem for characteristic zero is not in mathlib, but it is at
https://github.com/Jlh18/ModelTheoryInLean8
-/


noncomputable section

open MvPolynomial Finset Function

/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/
theorem ax_grothendieck_of_locally_finite {ι K R : Type _} [Field K] [Finite K] [CommRing R]
    [Finite ι] [Algebra K R] (alg : Algebra.IsAlgebraic K R) (ps : ι → MvPolynomial ι R)
    (hinj : Injective fun v i => MvPolynomial.eval v (ps i)) :
    Surjective fun v i => MvPolynomial.eval v (ps i) := by
  have is_int : ∀ x : R, IsIntegral K x := fun x => isAlgebraic_iff_isIntegral.1 (alg x)
  classical
    intro v
    cases nonempty_fintype ι
    /- `s` is the set of all coefficients of the polynomial, as well as all of
      the coordinates of `v`, the point I am trying to find the preimage of. -/
    let s : Finset R :=
      (Finset.biUnion (univ : Finset ι) fun i => (ps i).support.image fun x => coeff x (ps i)) ∪
        (univ : Finset ι).image v
    have hv : ∀ i, v i ∈ Algebra.adjoin K (s : Set R) := fun j =>
      Algebra.subset_adjoin (mem_union_right _ (mem_image.2 ⟨j, mem_univ _, rfl⟩))
    have hs₁ : ∀ (i : ι) (k : ι →₀ ℕ),
        k ∈ (ps i).support → coeff k (ps i) ∈ Algebra.adjoin K (s : Set R) :=
      fun i k hk => Algebra.subset_adjoin
        (mem_union_left _ (mem_biUnion.2 ⟨i, mem_univ _, mem_image_of_mem _ hk⟩))
    letI := isNoetherian_adjoin_finset s fun x _ => is_int x
    letI := Module.IsNoetherian.finite K (Algebra.adjoin K (s : Set R))
    letI : Finite (Algebra.adjoin K (s : Set R)) :=
      FiniteDimensional.finite_of_finite K (Algebra.adjoin K (s : Set R))
    -- The restriction of the polynomial map, `ps`, to the subalgebra generated by `s`
    let res : (ι → Algebra.adjoin K (s : Set R)) → ι → Algebra.adjoin K (s : Set R) := fun x i =>
      ⟨eval (fun j : ι => (x j : R)) (ps i), eval_mem (hs₁ _) fun i => (x i).2⟩
    have hres_inj : Injective res := by
      intro x y hxy
      ext i
      simp only [Subtype.ext_iff, funext_iff] at hxy
      exact congr_fun (hinj (funext hxy)) i
    have hres_surj : Surjective res := Finite.injective_iff_surjective.1 hres_inj
    cases' hres_surj fun i => ⟨v i, hv i⟩ with w hw
    use fun i => w i
    simpa only [Subtype.ext_iff, funext_iff] using hw
#align ax_grothendieck_of_locally_finite ax_grothendieck_of_locally_finite

end

namespace FirstOrder

open MvPolynomial FreeCommRing Language Language.field

def genericPolyMap {ι : Type _} (monoms : ι → Finset (ι →₀ ℕ)) :
    ι → FreeCommRing ((Σ i : ι, monoms i) ⊕ ι) :=
  fun i => (monoms i).attach.sum
    (fun m => FreeCommRing.of (Sum.inl ⟨i, m⟩) *
      Finsupp.prod m.1 (fun j n => FreeCommRing.of (Sum.inr j)^ n))

noncomputable def mvPolynomialSupportLEEquiv (ι : Type u)
    [DecidableEq ι] (R : Type _) [CommRing R] [DecidableEq R]
    (monoms : ι → Finset (ι →₀ ℕ)) :
    ({ p : ι → MvPolynomial ι R // ∀ i, (p i).support ⊆ monoms i }) ≃
      ((Σ i, monoms i) → R) :=
  { toFun := fun p i => (p.1 i.1).coeff i.2,
    invFun := fun p => ⟨fun i =>
      { toFun := fun m => if hm : m ∈ monoms i then p ⟨i, ⟨m, hm⟩⟩ else 0
        support := (monoms i).filter (fun m => ∃ hm : m ∈ monoms i, p ⟨i, ⟨m, hm⟩⟩ ≠ 0),
        mem_support_toFun := by  simp (config := {contextual := true}) },
      fun i => Finset.filter_subset _ _⟩,
    left_inv := fun p => by
      ext i m
      simp only [coeff, ne_eq, exists_prop, dite_eq_ite, Finsupp.coe_mk, ite_eq_left_iff]
      intro hm
      have : m ∉ (p.1 i).support := fun h => hm (p.2 i h)
      rw [MvPolynomial.mem_support_iff] at this
      simpa [coeff, eq_comm] using this
    right_inv := fun p => by ext; simp [coeff] }

@[simp]
theorem lift_genericPolyMap {R : Type _} [CommRing R]
    [DecidableEq ι] [DecidableEq R] (mons : ι → Finset (ι →₀ ℕ))
    (f :  (i : ι) × { x // x ∈ mons i } ⊕ ι → R) (i : ι) :
    FreeCommRing.lift (R := R) f (genericPolyMap mons i) =
      MvPolynomial.eval (f ∘ Sum.inr)
        (((mvPolynomialSupportLEEquiv ι R mons).symm
          (f ∘ Sum.inl)).1 i) := by
  conv_rhs => rw [MvPolynomial.eval_eq]
  simp only [genericPolyMap, Finsupp.prod_pow, map_sum, map_mul, lift_of, support,
    mvPolynomialSupportLEEquiv, coeff, map_prod,
    ne_eq, Function.comp, Equiv.coe_fn_symm_mk, Finsupp.coe_mk]
  rw [Finset.sum_filter]
  conv_rhs => rw [← Finset.sum_attach]
  refine Finset.sum_congr rfl ?_
  intros m _
  simp only [map_pow, lift_of, Subtype.coe_eta, Finset.coe_mem,
    exists_prop, true_and, dite_eq_ite, ite_true, ite_not]
  split_ifs with h0
  · simp_all
  · simp [Finsupp.prod, map_prod]

noncomputable def genericPolyMapSurjectiveOfInjective {ι : Type u} [Fintype ι]
    (mons : ι → Finset (ι →₀ ℕ)) : Language.field.Sentence :=
  let l1 : List (Language.field.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι))) :=
    (Finset.univ : Finset ι).toList.map (fun i =>
      (termOfFreeCommRing (genericPolyMap mons i)).relabel
        (Sum.inl ∘ Sum.map id (fun i => (0, i)))
    =' (termOfFreeCommRing (genericPolyMap mons i)).relabel
        (Sum.inl ∘ Sum.map id (fun i => (1, i))))
  let f1 : Language.field.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι)) :=
    l1.foldr (. ⊓ .) ⊤
  let l2 : List (Language.field.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι))) :=
    (Finset.univ : Finset ι).toList.map  (fun i =>
      .var (Sum.inl (Sum.inr (0, i))) =' .var (Sum.inl (Sum.inr (1, i))))
  let f2 : Language.field.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι)) :=
    l2.foldr (. ⊓ .) ⊤
  let inj : Language.field.Formula (Σ i : ι, mons i) :=
    Formula.allsᵢ (γ := Fin 2 × ι) id (f1 ⟹ f2)
  let l3 : List (Language.field.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι))) :=
    (Finset.univ : Finset ι).toList.map  (fun i =>
      (termOfFreeCommRing (genericPolyMap mons i)).relabel
        (Sum.inl ∘ Sum.map id (fun i => (0, i))) ='
      .var (Sum.inl (Sum.inr (1, i))))
  let f3 : Language.field.Formula ((Σ i : ι, mons i) ⊕ (Fin 2 × ι)) :=
    l3.foldr (. ⊓ .) ⊤
  let surj : Language.field.Formula (Σ i : ι, mons i) :=
    Formula.allsᵢ.{0, 0, u, u, u} (γ := ι) id
      (Formula.exsᵢ.{0, 0, u, u, u} (γ := ι)
        (fun (i : (Σ i : ι, mons i) ⊕ (Fin 2 × ι)) =>
          show ((Σ i : ι, mons i) ⊕ ι) ⊕ ι
          from Sum.elim (Sum.inl ∘ Sum.inl)
            (fun i => if i.1 = 0 then Sum.inr i.2 else (Sum.inl (Sum.inr i.2))) i) f3)
  Formula.allsᵢ (γ := Σ i : ι, mons i) Sum.inr (inj ⟹ surj)

theorem realize_genericPolyMapSurjectiveOfInjective
    {K : Type v} [CompatibleField K] {ι : Type u} [Fintype ι]
    (mons : ι → Finset (ι →₀ ℕ)) :
    (K ⊨ genericPolyMapSurjectiveOfInjective mons) ↔
      ∀ p : { p : ι → MvPolynomial ι K // (∀ i, (p i).support ⊆ mons i) },
        Function.Injective (fun v i => MvPolynomial.eval v (p.1 i)) →
        Function.Surjective (fun v i => MvPolynomial.eval v (p.1 i)) := by
  letI := Classical.decEq K
  letI := Classical.decEq ι
  rw [Equiv.forall_congr_left' (mvPolynomialSupportLEEquiv ι K mons)]
  simp only [Sentence.Realize, Formula.Realize, genericPolyMapSurjectiveOfInjective, Function.comp,
    Sum.map, id_eq, BoundedFormula.realize_allsᵢ, Sum.elim_inr, BoundedFormula.realize_imp,
    BoundedFormula.realize_foldr_inf, List.mem_map, Finset.mem_toList, Finset.mem_univ, true_and,
    forall_exists_index, forall_apply_eq_imp_iff', BoundedFormula.realize_bdEqual,
    Term.realize_relabel, Sum.elim_inl, realize_termOfFreeCommRing, lift_genericPolyMap,
    Term.realize_var, Equiv.forall_congr_left' (Equiv.curry (Fin 2) ι K), Equiv.curry_symm_apply,
    Function.uncurry_apply_pair, Fin.forall_fin_succ_pi, Fin.cons_zero, Fin.forall_fin_zero_pi,
    BoundedFormula.realize_exsᵢ, ite_true, one_ne_zero, ite_false, Function.Injective,
    Function.funext_iff, Function.Surjective]
  rfl

theorem ACF_models_genericPolyMapSurjectiveOfInjective_of_prime
    {ι : Type u} [Fintype ι]
    {p : ℕ} (hp : p.Prime) (mons : ι → Finset (ι →₀ ℕ)) :
    Theory.ACF p ⊨ᵇ genericPolyMapSurjectiveOfInjective mons := by
  letI := Classical.decEq ι
  haveI : Fact p.Prime := ⟨hp⟩
  letI := compatibleFieldOfField (AlgebraicClosure (ZMod p))
  haveI : CharP (AlgebraicClosure (ZMod p)) p :=
    charP_of_injective_algebraMap
      (RingHom.injective (algebraMap (ZMod p) (AlgebraicClosure (ZMod p)))) p
  rw [← (Language.ACF_isComplete_of_prime_or_zero (Or.inl hp)).realize_sentence_iff _
    (AlgebraicClosure (ZMod p)),
    realize_genericPolyMapSurjectiveOfInjective]
  rintro ⟨f, _⟩
  exact ax_grothendieck_of_locally_finite (K := ZMod p) (ι := ι)
    (IsAlgClosure.algebraic (R := ZMod p) (K := AlgebraicClosure (ZMod p))) f

theorem ACF_models_genericPolyMapSurjectiveOfInjective_of_prime_or_zero
    {ι : Type u} [Fintype ι]
    {p : ℕ} (hp : p.Prime ∨ p = 0) (mons : ι → Finset (ι →₀ ℕ)) :
    Theory.ACF p ⊨ᵇ genericPolyMapSurjectiveOfInjective mons := by
  rcases hp with hp | rfl
  · exact ACF_models_genericPolyMapSurjectiveOfInjective_of_prime hp mons
  · rw [ACF0_realize_iff_infinite_ACF_prime_realize]
    convert Set.infinite_univ (α := Nat.Primes)
    rw [Set.eq_univ_iff_forall]
    intro ⟨p, hp⟩
    exact ACF_models_genericPolyMapSurjectiveOfInjective_of_prime hp mons

end FirstOrder

open Function FirstOrder Language

theorem ax_grothendieck {ι K : Type _} [Field K] [Finite ι]
    [IsAlgClosed K] (ps : ι → MvPolynomial ι K) :
    Injective (fun v i => MvPolynomial.eval v (ps i)) →
    Surjective fun v i => MvPolynomial.eval v (ps i) := by
  letI := Fintype.ofFinite ι
  let p : ℕ := ringChar K
  haveI : CharP K p := ⟨ringChar.spec K⟩
  letI := compatibleFieldOfField K
  have := ACF_models_genericPolyMapSurjectiveOfInjective_of_prime_or_zero
    (CharP.char_is_prime_or_zero K p) (fun i => (ps i).support)
  rw [← (Language.ACF_isComplete_of_prime_or_zero
    (CharP.char_is_prime_or_zero K p)).realize_sentence_iff _ K,
    realize_genericPolyMapSurjectiveOfInjective] at this
  exact this ⟨ps, fun i => Finset.Subset.refl _⟩
