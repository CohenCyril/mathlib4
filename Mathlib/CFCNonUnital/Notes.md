There are essentially five tasks we need to accomplish to get a working non-unital continuous
functional calculus.

In the below, (3) and (5) depend on (2), but there are no other dependencies. In fact, the only
place in (5) where we use this is in the proof that we can restrict the codomain, so we could just
`sorry` that and do most of (5) independently too.

1. Write an instance of `NonUnitalContinuousFunctionalCalculus` given `ContinuousFunctionalCalculus`
   instance. This should be relatively straightforward. All we need to do is compose the continuous
   functional calculus with the `ContinuousMapZero.toContinuousMapHom` which is included in these
   files already, and we also have that it's a closed embedding. The only trick is that we actually
   need to work on subtypes instead (i.e., from `quasispectrum R a` to `spectrum R a`). This is just
   annoying, but unavoidable. The other facts should follow easily.
2. We need to show that the non-unital star-subalgebra generated by `id : ùïú ‚Üí ùïú` (appropriately
   restricted to a compact set) is dense in `C(X, ùïú)‚ÇÄ` for any compact `X : Set ùïú`. This is the hard
   bit that we worked on before, but which is unfinished. There is some useful material in the
   `AdjoinSpan` file.
3. We need to use (2) to get a `UniqueNonUnitalContinuousFunctionalCalculus`
   instance for `RCLike`, as is done in the unital case. Then, we need to jump through the same
   hoops as in the unital case to get it for `‚Ñù‚â•0` too.
4. We need to do restriction of the non-unital continuous functional calculus class just like is
   done for the unital ones. It would be nice if we don't have to duplicate `SpectrumRestricts`
   somehow for `quasispectrum`, but I'm not sure how hard it's going to be to unify the two, and I'm
   not entirely sure it's worth the effort (but maybe).
   You might take a look at the current proof of the restriction theorem `SpectrumRestricts.cfc` to
   see if the `closedEmbedding` bit can be simplified.
5. We need to use (2) to get a `NonUnitalContinuousFunctionalCalculus ‚ÑÇ (IsStarNormal : A ‚Üí Prop)`
   instance whenever `A` is a non-unital C‚ãÜ-algebra. The approach is as follows:

```lean
-- below, `‚Üëa := (a : Unitization ‚ÑÇ A)`
calc
  C(quasispectrum ‚ÑÇ a, ‚ÑÇ)‚ÇÄ ‚Üí‚ãÜ‚Çô‚Çê[‚ÑÇ] C(quasispectrum ‚ÑÇ a, ‚ÑÇ) := ContinuousMapZero.toContinuousMapHom
  _                        ‚âÉ‚ãÜ‚Çê[‚ÑÇ] C(spectrum ‚ÑÇ ‚Üëa, ‚ÑÇ) := by
    sorry
    -- `quasispectrum ‚ÑÇ a = spectrum ‚ÑÇ ‚Üëa`, so homeomorphic, hence algebras star-isomorphic.
  _                        ‚Üí‚ãÜ‚Çê[‚ÑÇ] Unitization ‚ÑÇ A := cfcHom ‚Üëa -- rather, proof of `IsStarNormal ‚Üëa`
```
Then since `C(quasispectrum ‚ÑÇ a, ‚ÑÇ)‚ÇÄ` is the closure of the non-unital star subalgebra generated by
`id : ‚ÑÇ ‚Üí ‚ÑÇ` (restricted appropriately and zero at zero), and because this map is continuous
(because we will show it's a closed embedding) we conclude that the range is included in the range
of the natural inclusion `A ‚Üí‚ãÜ‚Çô‚Çê[‚ÑÇ] Unitization ‚ÑÇ A`. So we restrict the codomain of the map above
to the range of this coercion to get a map
`C(quasispectrum ‚ÑÇ a, ‚ÑÇ)‚ÇÄ ‚Üí‚ãÜ‚Çô‚Çê[‚ÑÇ] (Unitization.inrNonUnitalStarAlgHom ‚ÑÇ A).range` and pull it back
through the coercion via the natural equiv to get a non-unital star algebra homomorphism into `A`.
The other facts should be (comparatively) easy to check (I think!).
