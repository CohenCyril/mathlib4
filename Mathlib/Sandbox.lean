import Mathlib

section Algebra

open Algebra

theorem Algebra.norm_smul {K : Type*} [Field K] {L : Type*} [Ring L] [Algebra K L] (x : L) (c : K) :
    Algebra.norm K (c ‚Ä¢ x) = c ^ FiniteDimensional.finrank K L * Algebra.norm K x := by
  classical
  rw [norm_apply, map_smul, LinearMap.det_smul, ‚Üê norm_apply]

end Algebra

noncomputable section NumberTheory

variable {K : Type*} [Field K] [NumberField K]

open NumberField.Units NumberField.Units.dirichletUnitTheorem NumberField NumberField.InfinitePlace
  FiniteDimensional -- MeasureTheory MeasureTheory.Measure

example (x : (ùìû K)À£) : |Algebra.norm ‚Ñö (x : K)| = 1 :=
  NumberField.isUnit_iff_norm.mp (Units.isUnit x)

open scoped BigOperators Classical

local notation "E" K =>
  ({w : InfinitePlace K // IsReal w} ‚Üí ‚Ñù) √ó ({w : InfinitePlace K // IsComplex w} ‚Üí ‚ÑÇ)

theorem NumberField.InfinitePlace.norm_embedding_eq_of_isReal {K : Type*} [Field K]
    {w : NumberField.InfinitePlace K} (hw : NumberField.InfinitePlace.IsReal w) (x : K) :
    ‚Äñembedding_of_isReal hw x‚Äñ = w x := by
  rw [‚Üê norm_embedding_eq, ‚Üê embedding_of_isReal_apply hw, Complex.norm_real]

namespace NumberField

def mixedEmbedding.norm : (E K) ‚Üí*‚ÇÄ ‚Ñù where
  toFun := fun x ‚Ü¶ (‚àè w, ‚Äñx.1 w‚Äñ) * ‚àè w, ‚Äñx.2 w‚Äñ ^ 2
  map_one' := by simp only [Prod.fst_one, Pi.one_apply, norm_one, Finset.prod_const_one,
    Prod.snd_one, one_pow, mul_one]
  map_zero' := by
    simp_rw [Prod.fst_zero, Prod.snd_zero, Pi.zero_apply, norm_zero, zero_pow (two_ne_zero),
      mul_eq_zero, Finset.prod_const, pow_eq_zero_iff', true_and, Finset.card_univ]
    by_contra!
    have : finrank ‚Ñö K = 0 := by
      rw [‚Üê card_add_two_mul_card_eq_rank, NrRealPlaces, NrComplexPlaces, this.1, this.2]
    exact ne_of_gt finrank_pos this
  map_mul' _ _ := by simp only [Prod.fst_mul, Pi.mul_apply, norm_mul, Real.norm_eq_abs,
      Finset.prod_mul_distrib, Prod.snd_mul, Complex.norm_eq_abs, mul_pow]; ring

theorem mixedEmbedding.norm_ne_zero {x : E K} :
    norm x ‚â† 0 ‚Üî (‚àÄ w, x.1 w ‚â† 0) ‚àß (‚àÄ w, x.2 w ‚â† 0) := by
  simp_rw [norm, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, mul_ne_zero_iff, Finset.prod_ne_zero_iff,
    Finset.mem_univ, forall_true_left, pow_ne_zero_iff two_ne_zero, norm_ne_zero_iff]

theorem mixedEmbedding.norm_smul (c : ‚Ñù) (x : E K) :
    norm (c ‚Ä¢ x) = |c| ^ finrank ‚Ñö K * (norm x) := by
  simp_rw [norm, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, Prod.smul_fst, Prod.smul_snd,
    Pi.smul_apply, Complex.real_smul, smul_eq_mul, norm_mul, Real.norm_eq_abs, Complex.norm_eq_abs,
    Complex.abs_ofReal, mul_pow, ‚Üê Finset.pow_card_mul_prod, ‚Üê pow_mul,
    ‚Üê card_add_two_mul_card_eq_rank, Finset.card_univ, pow_add]
  ring

@[simp]
theorem mixedEmbedding.norm_eq_norm (x : K) :
    norm (mixedEmbedding K x) = |Algebra.norm ‚Ñö x| := by
  simp_rw [‚Üê prod_eq_abs_norm, mixedEmbedding.norm, mixedEmbedding, RingHom.prod_apply,
    MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, Pi.ringHom_apply, norm_embedding_eq,
    norm_embedding_eq_of_isReal]
  rw [‚Üê Fintype.prod_subtype_mul_prod_subtype (fun w : InfinitePlace K ‚Ü¶ IsReal w)]
  congr 1
  ¬∑ exact Finset.prod_congr rfl (fun w _ ‚Ü¶ by rw [mult, if_pos w.prop, pow_one])
  ¬∑ refine (Fintype.prod_equiv (Equiv.subtypeEquivRight ?_) _ _ (fun w ‚Ü¶ ?_)).symm
    ¬∑ exact fun _ ‚Ü¶ not_isReal_iff_isComplex
    ¬∑ rw [Equiv.subtypeEquivRight_apply_coe, mult, if_neg w.prop]

theorem mixedEmbedding.norm_unit (u : (ùìû K)À£) :
    norm (mixedEmbedding K u) = 1 := by
  rw [norm_eq_norm, show |(Algebra.norm ‚Ñö) (u : K)| = 1
      by exact NumberField.isUnit_iff_norm.mp (Units.isUnit u), Rat.cast_one]

def mixedEmbedding.logMap (x : E K) : {w : InfinitePlace K // w ‚â† w‚ÇÄ} ‚Üí ‚Ñù :=
  fun w ‚Ü¶
    if hw : IsReal w.val then
      Real.log ‚Äñx.1 ‚ü®w.val, hw‚ü©‚Äñ - Real.log (norm x) * (finrank ‚Ñö K : ‚Ñù)‚Åª¬π
    else
      2 * (Real.log ‚Äñx.2 ‚ü®w.val, not_isReal_iff_isComplex.mp hw‚ü©‚Äñ -
        Real.log (norm x) * (finrank ‚Ñö K : ‚Ñù)‚Åª¬π)

-- theorem mixedEmbedding.logMap_apply_of_isReal (x : E K) (w : {w : InfinitePlace K // w ‚â† w‚ÇÄ})
--     (hw : IsReal w.val) : logMap x w =
--       Real.log ‚Äñx.1 ‚ü®w.val, hw‚ü©‚Äñ - Real.log (mixedEmbedding.norm x) * (finrank ‚Ñö K : ‚Ñù)‚Åª¬π := by
--   rw [logMap, dif_pos hw]

-- theorem mixedEmbedding.logMap_apply_of_isComplex (x : E K) (w : {w : InfinitePlace K // w ‚â† w‚ÇÄ})
--     (hw : IsComplex w.val) : logMap x w = 2 * (Real.log ‚Äñx.2 ‚ü®w.val, hw‚ü©‚Äñ -
--       Real.log (mixedEmbedding.norm x) * (finrank ‚Ñö K : ‚Ñù)‚Åª¬π) := by
--   rw [logMap, dif_neg (not_isReal_iff_isComplex.mpr hw)]

theorem mixedEmbedding.logMap_zero : logMap (0 : E K) = 0 := by
  ext
  simp_rw [mixedEmbedding.logMap, Prod.fst_zero, Prod.snd_zero, map_zero, Pi.zero_apply, norm_zero,
    Real.log_zero, zero_mul, sub_zero, mul_zero, dite_eq_ite, ite_self]

theorem mixedEmbedding.logMap_mul {x y : E K} (hx : norm x ‚â† 0) (hy : norm y ‚â† 0) :
    logMap (x * y) = logMap x + logMap y := by
  ext w
  simp_rw [Pi.add_apply, logMap]
  split_ifs with hw
  ¬∑ rw [Prod.fst_mul, Pi.mul_apply, norm_mul, map_mul, Real.log_mul, Real.log_mul hx hy, add_mul]
    ring
    exact norm_ne_zero_iff.mpr <| (mixedEmbedding.norm_ne_zero.mp hx).1 ‚ü®_, hw‚ü©
    exact norm_ne_zero_iff.mpr <| (mixedEmbedding.norm_ne_zero.mp hy).1 ‚ü®_, hw‚ü©
  ¬∑ replace hw := not_isReal_iff_isComplex.mp hw
    rw [Prod.snd_mul, Pi.mul_apply, norm_mul, map_mul, Real.log_mul, Real.log_mul hx hy, add_mul]
    ring
    exact norm_ne_zero_iff.mpr <| (mixedEmbedding.norm_ne_zero.mp hx).2 ‚ü®_, hw‚ü©
    exact norm_ne_zero_iff.mpr <| (mixedEmbedding.norm_ne_zero.mp hy).2 ‚ü®_, hw‚ü©

theorem mixedEmbedding.logMap_eq_logEmbedding (u : (ùìû K)À£) :
    logMap (mixedEmbedding K u) = logEmbedding K u := by
  ext
  simp_rw [logMap, norm_unit, Real.log_one, zero_mul, sub_zero, logEmbedding, AddMonoidHom.coe_mk,
    ZeroHom.coe_mk, mult, Nat.cast_ite, ite_mul, Nat.cast_one, one_mul, Nat.cast_ofNat,
    mixedEmbedding, RingHom.prod_apply, Pi.ringHom_apply, norm_embedding_eq,
    norm_embedding_eq_of_isReal]
  rfl

instance : MulAction (ùìû K)À£ (E K) where
  smul := fun u x ‚Ü¶ (mixedEmbedding K u) * x
  one_smul := fun _ ‚Ü¶ by simp_rw [HSMul.hSMul, Units.coe_one, map_one, one_mul]
  mul_smul := fun _ _ _ ‚Ü¶ by simp_rw [HSMul.hSMul, Units.coe_mul, map_mul, mul_assoc]

-- For some reason, Lean cannot deduce that by itself
instance : SMul (ùìû K)À£ (E K) := MulAction.toSMul

theorem unit_smul_def (u : (ùìû K)À£) (x : E K) : u ‚Ä¢ x = (mixedEmbedding K u) * x := rfl

theorem mixedEmbedding.logMap_unit_smul_eq (u : (ùìû K)À£) {x : E K} (hx : norm x ‚â† 0) :
    logMap (u ‚Ä¢ x) = logEmbedding K u + logMap x := by
  rw [unit_smul_def, logMap_mul (by rw [norm_unit]; norm_num) hx, logMap_eq_logEmbedding]

theorem mixedEmbedding.logMap_smul_eq_self {x : E K} {c : ‚Ñù} (hx : norm x ‚â† 0) (hc : c ‚â† 0) :
    logMap (c ‚Ä¢ x) = logMap x := by
  have hr : (finrank ‚Ñö K : ‚Ñù) ‚â† 0 :=  Nat.cast_ne_zero.mpr (ne_of_gt finrank_pos)
  ext w
  rw [logMap, logMap, norm_smul, Real.log_mul (pow_ne_zero _ (abs_ne_zero.mpr hc)) hx,
    Real.log_pow, add_mul, mul_comm, inv_mul_cancel_left‚ÇÄ hr, Prod.smul_fst, Prod.smul_snd]
  simp_rw [Pi.smul_apply, Complex.real_smul, smul_eq_mul, norm_mul]
  simp_rw [Real.norm_eq_abs, Complex.norm_eq_abs, Complex.abs_ofReal]
  congr with hw
  ¬∑ rw [Real.log_mul (abs_ne_zero.mpr hc) (abs_ne_zero.mpr ((norm_ne_zero.mp hx).1 ‚ü®w, hw‚ü©))]
    ring
  ¬∑ rw [Real.log_mul (abs_ne_zero.mpr hc)
      (AbsoluteValue.ne_zero _ ((norm_ne_zero.mp hx).2 ‚ü®w, not_isReal_iff_isComplex.mp hw‚ü©))]
    ring

variable (K) in
def mixedEmbedding.cone : Set (E K) := by
  let B := (Module.Free.chooseBasis ‚Ñ§ (unitLattice K)).ofZlatticeBasis ‚Ñù _
  exact logMap‚Åª¬π' (Zspan.fundamentalDomain B)

variable (K) in
theorem mixedEmbedding.cone_zero_mem : 0 ‚àà cone K := by
  simp_rw [cone, Set.mem_preimage, Zspan.mem_fundamentalDomain, logMap_zero, map_zero,
    Finsupp.coe_zero, Pi.zero_apply, Set.left_mem_Ico, zero_lt_one, implies_true]

theorem mixedEmbedding.exists_unit_mul_mem_cone {x : E K} (hx : norm x ‚â† 0) :
    ‚àÉ u : (ùìû K)À£, u ‚Ä¢ x ‚àà cone K := by
  let B := (Module.Free.chooseBasis ‚Ñ§ (unitLattice K)).ofZlatticeBasis ‚Ñù
  rsuffices ‚ü®‚ü®_, ‚ü®u, _, rfl‚ü©‚ü©, hu‚ü© : ‚àÉ e : unitLattice K, e + logMap x ‚àà Zspan.fundamentalDomain B
  ¬∑ exact ‚ü®u, by rwa [cone, Set.mem_preimage, logMap_unit_smul_eq u hx]‚ü©
  ¬∑ obtain ‚ü®‚ü®e, h‚ÇÅ‚ü©, h‚ÇÇ, -‚ü© := Zspan.exist_unique_vadd_mem_fundamentalDomain B (logMap x)
    exact ‚ü®‚ü®e, by rwa [‚Üê Basis.ofZlatticeBasis_span ‚Ñù (unitLattice K)]‚ü©, h‚ÇÇ‚ü©

theorem mixedEmbedding.torsion_smul_mem_cone_of_mem_cone {x : E K} (hx : norm x ‚â† 0)
    (hx' : x ‚àà cone K) {Œ∂ : (ùìû K)À£} (hŒ∂ : Œ∂ ‚àà torsion K) : Œ∂ ‚Ä¢ x ‚àà cone K := by
  rwa [cone, Set.mem_preimage, logMap_unit_smul_eq _ hx, logEmbedding_eq_zero_iff.mpr hŒ∂, zero_add]

theorem mixedEmbedding.smul_mem_cone_iff {x : E K} {u : (ùìû K)À£} (hx : norm x ‚â† 0)
    (hx' : x ‚àà cone K) :
    u ‚Ä¢ x ‚àà cone K ‚Üî u ‚àà torsion K := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ rw [‚Üê logEmbedding_eq_zero_iff]
    let B := (Module.Free.chooseBasis ‚Ñ§ (unitLattice K)).ofZlatticeBasis ‚Ñù
    refine (Subtype.mk_eq_mk (h := ?_) (h' := ?_)).mp <|
      ExistsUnique.unique (Zspan.exist_unique_vadd_mem_fundamentalDomain B (logMap x)) ?_ ?_
    ¬∑ change logEmbedding K u ‚àà (Submodule.span ‚Ñ§ (Set.range B)).toAddSubgroup
      rw [Basis.ofZlatticeBasis_span ‚Ñù (unitLattice K)]
      exact ‚ü®u, trivial, rfl‚ü©
    ¬∑ exact zero_mem _
    ¬∑ rwa [cone, Set.mem_preimage, logMap_unit_smul_eq _ hx] at h
    ¬∑ rw [AddSubmonoid.mk_vadd, vadd_eq_add, zero_add]
      rwa [cone, Set.mem_preimage] at hx'
  ¬∑ exact torsion_smul_mem_cone_of_mem_cone hx hx' h

theorem mixedEmbedding.mul_mem_cone_of_mem_cone {x : E K} (hx : norm x ‚â† 0)
    (hx' : x ‚àà cone K) {c : ‚Ñù} (hc : c ‚â† 0) :
    c ‚Ä¢ x ‚àà cone K := by rwa [cone, Set.mem_preimage, logMap_smul_eq_self hx hc]

variable (K) in
def conePoint : Set (ùìû K) := { x | mixedEmbedding K x ‚àà mixedEmbedding.cone K}

theorem mem_conePoint_iff {x : ùìû K} :
    x ‚àà conePoint K ‚Üî mixedEmbedding K x ‚àà mixedEmbedding.cone K := by rfl

variable (K) in
theorem zero_mem_conePoint : 0 ‚àà conePoint K := by
  rw [mem_conePoint_iff, ZeroMemClass.coe_zero, map_zero]
  exact mixedEmbedding.cone_zero_mem K

theorem generators_in_conePoint_eq_range {I : Ideal (ùìû K)} {g : ùìû K} (hg‚ÇÅ : Ideal.span {g} = I)
    (hg‚ÇÇ : g ‚àà conePoint K) :
      {x : ùìû K | Ideal.span {x} = I} ‚à© conePoint K =
        Set.range (fun Œ∂ : torsion K ‚Ü¶ Œ∂.val‚Åª¬π * g) := by
  by_cases hg‚ÇÄ : g = 0
  ¬∑ rw [hg‚ÇÄ, Set.singleton_zero, Ideal.span_zero] at hg‚ÇÅ
    simp_rw [‚Üê hg‚ÇÅ, hg‚ÇÄ, mul_zero, Set.range_const, Ideal.span_singleton_eq_bot,
      Set.setOf_eq_eq_singleton, Set.inter_eq_left]
    exact Set.singleton_subset_iff.mpr (zero_mem_conePoint K)
  ¬∑ ext x
    simp_rw [‚Üê hg‚ÇÅ, Ideal.span_singleton_eq_span_singleton, Set.mem_inter_iff, mem_conePoint_iff]
    refine ‚ü®fun ‚ü®‚ü®u, hu‚ü©, hx‚ü© ‚Ü¶ ‚ü®‚ü®u, ?_‚ü©, ?_‚ü©, fun ‚ü®‚ü®Œ∂, hŒ∂‚ü©, hx‚ü© ‚Ü¶ ‚ü®‚ü®Œ∂, ?_‚ü©, ?_‚ü©‚ü©
    ¬∑ rw [‚Üê mixedEmbedding.smul_mem_cone_iff ?_ hx]
      rwa [unit_smul_def, ‚Üê map_mul, ‚Üê Submonoid.coe_mul, mul_comm, hu, ‚Üê mem_conePoint_iff]
      rw [mul_comm, eq_comm, ‚Üê Units.inv_mul_eq_iff_eq_mul] at hu
      rw [‚Üê hu]
      simp [hg‚ÇÄ]
    ¬∑ rwa [Units.inv_mul_eq_iff_eq_mul, mul_comm, eq_comm]
    ¬∑ rwa [mul_comm, ‚Üê Units.eq_inv_mul_iff_mul_eq, eq_comm]
    ¬∑ rw [‚Üê hx, Submonoid.coe_mul, map_mul, ‚Üê unit_smul_def]
      refine mixedEmbedding.torsion_smul_mem_cone_of_mem_cone ?_ ?_ ?_
      ¬∑ simp [hg‚ÇÄ]
      ¬∑ exact mem_conePoint_iff.mp hg‚ÇÇ
      ¬∑ exact inv_mem hŒ∂

open Submodule

theorem exists_generator_in_conePoint {I : Ideal (ùìû K)} (hI : IsPrincipal I) :
    ‚àÉ g ‚àà conePoint K, Ideal.span {g} = I := by
  obtain ‚ü®x, hx‚ü© := hI.principal
  rw [Ideal.submodule_span_eq] at hx
  by_cases hx‚ÇÄ : x = 0
  ¬∑ exact ‚ü®0, zero_mem_conePoint K, by rw [hx, hx‚ÇÄ]‚ü©
  ¬∑ obtain ‚ü®u, hu‚ü© := mixedEmbedding.exists_unit_mul_mem_cone (x := mixedEmbedding K x) (by simpa)
    refine ‚ü®u * x, ?_, ?_‚ü©
    ¬∑ rwa [mem_conePoint_iff, Submonoid.coe_mul, map_mul, ‚Üê unit_smul_def]
    ¬∑ rw [hx, Ideal.span_singleton_eq_span_singleton]
      exact ‚ü®u‚Åª¬π, by rw [mul_comm, Units.inv_mul_cancel_left]‚ü©


#exit

  refine ‚ü®fun ‚ü®‚ü®u, hu‚ü©, hx‚ü© ‚Ü¶ ?_, fun ‚ü®‚ü®Œ∂, hŒ∂‚ü©, hx‚ü© ‚Ü¶ ‚ü®‚ü®Œ∂, ?_‚ü©, ?_‚ü©‚ü©
  ¬∑ refine ‚ü®‚ü®?_, ?_‚ü©, ?_‚ü©

    sorry
  ¬∑ rwa [mul_comm, ‚Üê Units.eq_inv_mul_iff_mul_eq, eq_comm]
  ¬∑ rw [mem_conePoint_iff, ‚Üê hx, Submonoid.coe_mul, map_mul, ‚Üê unit_smul_def]
    refine mixedEmbedding.torsion_smul_mem_cone_of_mem_cone ?_ ?_ ?_
    ¬∑ simp [hg‚ÇÄ]
    ¬∑ exact mem_conePoint_iff.mp hg‚ÇÇ
    ¬∑ exact inv_mem hŒ∂

#exit


  refine ‚ü®fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ ?_, fun ‚ü®‚ü®Œ∂, hŒ∂‚ü©, hx‚ü© ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©


#exit

  ¬∑ refine ‚ü®‚ü®?_, ?_‚ü©, ?_‚ü©
    ¬∑ rw [‚Üê hg‚ÇÅ] at h‚ÇÅ

      sorry
    ¬∑
      sorry
    ¬∑
      sorry
  ¬∑ -- refine Ideal.span_singleton_eq_span_singleton.mpr ‚ü®Œ∂, ?_‚ü©
    rwa [mul_comm, ‚Üê Units.eq_inv_mul_iff_mul_eq, eq_comm]
  . rw [mem_conePoint_iff, ‚Üê hx, Submonoid.coe_mul, map_mul, ‚Üê unit_smul_def]
    refine mixedEmbedding.torsion_smul_mem_cone_of_mem_cone ?_ ?_ ?_
    ¬∑ rw [mixedEmbedding.norm_eq_norm, Rat.cast_ne_zero, abs_ne_zero, Algebra.norm_ne_zero_iff]
      exact_mod_cast hg‚ÇÄ
    ¬∑ rw [‚Üê mem_conePoint_iff]
      exact hg‚ÇÇ
    ¬∑ exact inv_mem hŒ∂

#exit

open scoped nonZeroDivisors

def reducedModUnit (x : (ùìû K)) : ùìû K := by
  by_cases hx : x = 0
  ¬∑ exact 0
  ¬∑ have := mixedEmbedding.exists_unit_mul_mem_cone (x := mixedEmbedding K x) (by simpa)
    exact this.choose * x

theorem reducedModUnit_zero : reducedModUnit (0 : ùìû K) = 0 := by simp [reducedModUnit]

theorem associated_reducedModUnit (x : (ùìû K)) : Associated x (reducedModUnit x) := by
  by_cases hx : x = 0
  ¬∑ exact ‚ü®1, by rw [Units.val_one, mul_one, hx, reducedModUnit_zero]‚ü©
  ¬∑ have := mixedEmbedding.exists_unit_mul_mem_cone (x := mixedEmbedding K x) (by simpa)
    refine ‚ü®this.choose, ?_‚ü©
    rw [mul_comm, reducedModUnit, dif_neg hx]

theorem reducedModUnit_conePoint (x : (ùìû K)) :
    reducedModUnit x ‚àà conePoint K := by
  rw [mem_conePoint_iff]
  by_cases hx : x = 0
  ¬∑ rw [hx, reducedModUnit_zero, ZeroMemClass.coe_zero, map_zero]
    exact mixedEmbedding.cone_zero_mem K
  ¬∑ have := mixedEmbedding.exists_unit_mul_mem_cone (x := mixedEmbedding K x) (by simpa)
    rw [reducedModUnit, dif_neg hx, Submonoid.coe_mul, map_mul]
    exact this.choose_spec

open Submodule mixedEmbedding

theorem reducedGenerators {I : Ideal (ùìû K)} (hI : IsPrincipal I) :
    {x : ùìû K | Ideal.span {x} = I} ‚à© conePoint K =
      Set.range (fun Œ∂ : torsion K ‚Ü¶ Œ∂.val‚Åª¬π * (reducedModUnit hI.generator)) := by
  ext x
  refine ‚ü®fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ ?_, ?_‚ü©
  ¬∑ have := Ideal.span_singleton_eq_span_singleton.mpr (associated_reducedModUnit hI.generator)
    have t1 : Ideal.span {x} = I := by exact h‚ÇÅ
    rw [Ideal.span_singleton_generator] at this
    have := Eq.trans t1 this -- seems that we have to do it the hard way
    rw [Ideal.span_singleton_eq_span_singleton] at this
    let u := this.choose
    let hu := this.choose_spec
    refine ‚ü®‚ü®u, ?_‚ü©, ?_‚ü©
    ¬∑ rw [mem_conePoint_iff] at h‚ÇÇ
      have : u ‚Ä¢ mixedEmbedding K x ‚àà cone K := by
        rw [unit_smul_def, mul_comm, ‚Üê map_mul, ‚Üê Submonoid.coe_mul, ‚Üê mem_conePoint_iff, hu]
        exact reducedModUnit_conePoint _
      exact (mixedEmbedding.smul_mem_cone_iff sorry h‚ÇÇ).mp this
    ¬∑ dsimp?
      rw [‚Üê hu]
      field_simp

#exit
    have : span (ùìû K) {reducedModUnit hI.generator} = I := sorry

    have := Ideal.span_singleton_eq_span_singleton.mp

    sorry
  ¬∑
    sorry


#exit

    rw [Rat.cast_ne_zero, abs_ne_zero, Algebra.norm_ne_zero_iff]

def mixedEmbedding.generator {I : (Ideal (ùìû K))‚Å∞} (hI : IsPrincipal I.val) :
    conePoint K := by
  have := mixedEmbedding.exists_unit_mul_mem_cone (x := mixedEmbedding K hI.generator) ?_
  ¬∑ refine ‚ü®this.choose * hI.generator, ?_, ?_‚ü©
    ¬∑ rw [Set.mem_setOf_eq, Set.mem_preimage, Submonoid.coe_mul, map_mul]
      exact this.choose_spec
    ¬∑
      simp only [Set.mem_preimage, ne_eq, Zspan.mem_fundamentalDomain, Set.mem_Ico,
        Set.mem_singleton_iff, mul_eq_zero, Units.ne_zero, false_or]
      sorry
  ¬∑ sorry

#exit

def mixedEmbedding.conePoint : Set (E K) := cone K ‚à© mixedEmbedding K '' (ùìû K)

def mixedEmbedding.associatedConePoint (x : ùìû K) : conePoint K := by
  by_cases hx : x = 0
  ¬∑ have : 0 ‚àà conePoint K := by
      refine ‚ü®?_, ?_‚ü©
      exact cone_zero_mem
      refine ‚ü®0, ?_, ?_‚ü©
      exact zero_mem (ùìû K)
      rw [map_zero]
    exact ‚ü®0, this‚ü©
  ¬∑ have h := mixedEmbedding.exists_unit_mul_mem_cone (x := mixedEmbedding K x) ?_
    ¬∑ refine ‚ü®h.choose ‚Ä¢ mixedEmbedding K x, h.choose_spec, ?_‚ü©
      ¬∑ refine ‚ü®h.choose * x, ?_, ?_‚ü©
        ¬∑ refine mul_mem ?_ ?_
          exact SetLike.coe_mem h.choose.val
          exact SetLike.coe_mem x
        ¬∑ rw [smul_def, map_mul]
    rw [norm_eq_norm, Rat.cast_ne_zero, abs_ne_zero, Algebra.norm_ne_zero_iff]
    exact_mod_cast hx

#exit

open Submodule

example (x y : (ùìû K)) (h : span (ùìû K) { x } = span (ùìû K) { y }) : Associated x y := by
  exact Ideal.span_singleton_eq_span_singleton.mp h

def mixedEmbedding.associatedPoint {I : Ideal (ùìû K)} (hI : IsPrincipal I) : conePoints K := by
  let Œ± := hI.generator
  have := mixedEmbedding.exists_unit_mul_mem_cone (x := mixedEmbedding K Œ±) ?_
  let u := this.choose
  refine ‚ü®u ‚Ä¢ mixedEmbedding K Œ±, ?_, ?_‚ü©
  exact this.choose_spec
  refine ‚ü®u * Œ±, ?_, ?_‚ü©
  ¬∑ simp only [SetLike.mem_coe]
    refine mul_mem ?_ ?_
    exact SetLike.coe_mem u.val
    exact SetLike.coe_mem Œ±
  ¬∑ rw [smul_def, map_mul]
  sorry









#exit

open Submodule mixedEmbedding

open scoped nonZeroDivisors

variable (K)



def Gen (I : (Ideal (ùìû K))‚Å∞) [hI : IsPrincipal I.val] : ùìû K := sorry

theorem Gen_span (I : (Ideal (ùìû K))‚Å∞) [hI : IsPrincipal I.val] :
    span (ùìû K) { Gen K I } = I.val := sorry

theorem Gen_mem_conePoints (I : (Ideal (ùìû K))‚Å∞) [hI : IsPrincipal I.val] :
    mixedEmbedding K (Gen K I) ‚àà conePoints K := sorry

def conePoints_equiv :
    {I : (Ideal (ùìû K))‚Å∞ // IsPrincipal I.val} √ó (torsion K) ‚âÉ conePoints K := by


  sorry



#exit

theorem zap‚ÇÅ (x : ùìû K) :
    mixedEmbedding K x ‚àà conePoints K ‚Üî
def coneToPrincipalIdeal (x : conePoints K) : {I : Ideal (ùìû K) // IsPrincipal I} := sorry

theorem coneToPrincipalIdeal_norm_eq (x : conePoints K) :
    mixedEmbedding.norm (x : E K) = Ideal.absNorm (coneToPrincipalIdeal x).val := sorry

theorem coneToPrincipalIdeal_surjective :
    Function.Surjective (coneToPrincipalIdeal (K := K)) := sorry

-- This result actually implies the previous one
theorem coneToPrincipalIdeal_card_fiber_eq (I : {I : Ideal (ùìû K) // IsPrincipal I}) :
    Nat.card {x : conePoints K | coneToPrincipalIdeal x = I} = Fintype.card (torsion K) := sorry

example (k : ‚Ñï) :
    Nat.card {x : conePoints K // mixedEmbedding.norm (x : E K) ‚â§ k} =
      Fintype.card (torsion K) *
        Nat.card {I : Ideal (ùìû K) | IsPrincipal I ‚àß Ideal.absNorm I ‚â§ k} := by
  rw [‚Üê Nat.card_eq_fintype_card, ‚Üê Nat.card_prod]
  refine Nat.card_congr ?_





example (I : Ideal (ùìû K)) [hI : IsPrincipal I] : (ùìû K)À£ := by
  let x := (IsPrincipal.principal I).choose
  let y := mixedEmbedding.logMap (mixedEmbedding K x)
  let B‚ÇÄ := Module.Free.chooseBasis ‚Ñ§ (unitLattice K)
  let B := B‚ÇÄ.ofZlatticeBasis ‚Ñù _
  have := Zspan.exist_unique_vadd_mem_fundamentalDomain B y
  let v := this.choose
  have : ‚Üëv ‚àà unitLattice K := by
    simp_rw [‚Üê B‚ÇÄ.ofZlatticeBasis_span ‚Ñù (unitLattice K)]
    exact SetLike.coe_mem v
  let u := this.choose
  exact u






end NumberTheory

#exit

open Filter BigOperators Asymptotics Topology

section RiemannZeta

theorem zap0 :
    Tendsto (fun s : ‚ÑÇ ‚Ü¶ (s - 1) * ‚àë' (n : ‚Ñï), 1 / (n:‚ÑÇ) ^ s)
      (ùìù[{s | 1 < s.re}] 1) (ùìù 1) := by
  have : Tendsto (fun s : ‚ÑÇ ‚Ü¶ (s - 1) * riemannZeta s) (ùìù[{s | 1 < s.re}] 1) (ùìù 1) := by
    refine Filter.Tendsto.mono_left riemannZeta_residue_one ?_
    refine nhdsWithin_mono _ ?_
    aesop
  refine Tendsto.congr' ?_ this
  rw [eventuallyEq_nhdsWithin_iff]
  refine eventually_of_forall (fun s hs ‚Ü¶ ?_)
  exact congr_arg ((s - 1) * ¬∑) (zeta_eq_tsum_one_div_nat_cpow hs)

end RiemannZeta

section Eventually

theorem le_of_frequently_sub_le {Œ± : Type*} [LinearOrderedField Œ±] [TopologicalSpace Œ±]
    [OrderTopology Œ±] {a b : Œ±} (h : ‚àÉ·∂† Œµ in ùìù[>] 0, b - Œµ ‚â§ a) : b ‚â§ a := by
  contrapose! h
  obtain ‚ü®c, hc‚ü© := exists_add_lt_and_pos_of_lt h
  refine not_frequently.mpr <|
    eventually_iff_exists_mem.mpr ‚ü®Set.Ioc 0 c, Ioc_mem_nhdsWithin_Ioi' hc.2, fun _ hx ‚Ü¶ ?_‚ü©
  exact not_le.mpr <| lt_of_lt_of_le (lt_tsub_of_add_lt_right hc.1) (sub_le_sub_left hx.2 b)

theorem le_of_frequently_le_add {Œ± : Type*} [LinearOrderedField Œ±] [TopologicalSpace Œ±]
    [OrderTopology Œ±] {a b : Œ±} (h : ‚àÉ·∂† Œµ in ùìù[>] 0, b ‚â§ a + Œµ) : b ‚â§ a := by
  simp_rw [‚Üê sub_le_iff_le_add] at h
  exact le_of_frequently_sub_le h

end Eventually

section IsBounded

@[to_additive]
theorem IsBoundedUnder_le_mul_right {Œ± Œ≤ : Type*} [OrderedCommGroup Œ±] {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±}
    (a : Œ±) (hu : IsBoundedUnder (¬∑ ‚â§ ¬∑) f u) :
    IsBoundedUnder (¬∑ ‚â§ ¬∑) f (fun x ‚Ü¶ u x * a) :=
  (OrderIso.mulRight a).isBoundedUnder_le_comp.mpr hu

@[to_additive]
theorem IsBoundedUnder_le_mul_left {Œ± Œ≤ : Type*} [OrderedCommGroup Œ±] {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±}
    (a : Œ±) (hu : IsBoundedUnder (¬∑ ‚â§ ¬∑) f u) :
    IsBoundedUnder (¬∑ ‚â§ ¬∑) f (fun x ‚Ü¶ a * u x) :=
  (OrderIso.mulLeft a).isBoundedUnder_le_comp.mpr hu

@[to_additive]
theorem IsBoundedUnder_le_mul {Œ± Œ≤ : Type*} [OrderedCommGroup Œ±] {f : Filter Œ≤} {u v : Œ≤ ‚Üí Œ±}
    (hu : IsBoundedUnder (¬∑ ‚â§ ¬∑) f u) (hv : IsBoundedUnder (¬∑ ‚â§ ¬∑) f v) :
    IsBoundedUnder (¬∑ ‚â§ ¬∑) f (u * v) := by
  obtain ‚ü®bu, hu‚ü© := hu
  obtain ‚ü®bv, hv‚ü© := hv
  refine ‚ü®bu * bv, ?_‚ü©
  rw [eventually_map] at hu hv ‚ä¢
  filter_upwards [hu, hv] with _ h‚ÇÅ h‚ÇÇ using mul_le_mul' h‚ÇÅ h‚ÇÇ

@[to_additive]
theorem IsBoundedUnder_ge_mul_right {Œ± Œ≤ : Type*} [OrderedCommGroup Œ±] {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±}
    (a : Œ±) (hu : IsBoundedUnder (¬∑ ‚â• ¬∑) f u) :
    IsBoundedUnder (¬∑ ‚â• ¬∑) f (fun x ‚Ü¶ u x * a) :=
  (OrderIso.mulRight a).isBoundedUnder_ge_comp.mpr hu

@[to_additive]
theorem IsBoundedUnder_ge_mul_left {Œ± Œ≤ : Type*} [OrderedCommGroup Œ±] {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±}
    (a : Œ±) (hu : IsBoundedUnder (¬∑ ‚â• ¬∑) f u) :
    IsBoundedUnder (¬∑ ‚â• ¬∑) f (fun x ‚Ü¶ a * u x) :=
  (OrderIso.mulLeft a).isBoundedUnder_ge_comp.mpr hu

@[to_additive]
theorem IsBoundedUnder_ge_mul {Œ± Œ≤ : Type*} [OrderedCommGroup Œ±] {f : Filter Œ≤} {u v : Œ≤ ‚Üí Œ±}
    (hu : IsBoundedUnder (¬∑ ‚â• ¬∑) f u) (hv : IsBoundedUnder (¬∑ ‚â• ¬∑) f v) :
    IsBoundedUnder (¬∑ ‚â• ¬∑) f (u * v) := by
  obtain ‚ü®bu, hu‚ü© := hu
  obtain ‚ü®bv, hv‚ü© := hv
  refine ‚ü®bu * bv, ?_‚ü©
  rw [eventually_map] at hu hv ‚ä¢
  filter_upwards [hu, hv] with _ h‚ÇÅ h‚ÇÇ using mul_le_mul' h‚ÇÅ h‚ÇÇ

-- Mathlib.Order.LiminfLimsup
-- #find_home IsBoundedUnder_ge_mul

theorem IsBoundedUnder_le_mul_right‚ÇÄ {Œ± Œ≤ : Type*} [LinearOrderedSemifield Œ±] {f : Filter Œ≤}
    {u : Œ≤ ‚Üí Œ±} {a : Œ±} (ha : 0 < a) (hu : IsBoundedUnder (¬∑ ‚â§ ¬∑) f u) :
    IsBoundedUnder (¬∑ ‚â§ ¬∑) f (fun x ‚Ü¶ u x * a) :=
  (OrderIso.mulRight‚ÇÄ a ha).isBoundedUnder_le_comp.mpr hu

theorem IsBoundedUnder_le_mul_left‚ÇÄ {Œ± Œ≤ : Type*} [LinearOrderedSemifield Œ±] {f : Filter Œ≤}
    {u : Œ≤ ‚Üí Œ±} {a : Œ±} (ha : 0 < a) (hu : IsBoundedUnder (¬∑ ‚â§ ¬∑) f u) :
    IsBoundedUnder (¬∑ ‚â§ ¬∑) f (fun x ‚Ü¶ a * u x) :=
  (OrderIso.mulLeft‚ÇÄ a ha).isBoundedUnder_le_comp.mpr hu

theorem IsBoundedUnder_ge_mul_right‚ÇÄ {Œ± Œ≤ : Type*} [LinearOrderedSemifield Œ±] {f : Filter Œ≤}
    {u : Œ≤ ‚Üí Œ±} {a : Œ±} (ha : 0 < a) (hu : IsBoundedUnder (¬∑ ‚â• ¬∑) f u) :
    IsBoundedUnder (¬∑ ‚â• ¬∑) f (fun x ‚Ü¶ u x * a) :=
  (OrderIso.mulRight‚ÇÄ a ha).isBoundedUnder_ge_comp.mpr hu

theorem IsBoundedUnder_ge_mul_left‚ÇÄ {Œ± Œ≤ : Type*} [LinearOrderedSemifield Œ±] {f : Filter Œ≤}
    {u : Œ≤ ‚Üí Œ±} {a : Œ±} (ha : 0 < a) (hu : IsBoundedUnder (¬∑ ‚â• ¬∑) f u) :
    IsBoundedUnder (¬∑ ‚â• ¬∑) f (fun x ‚Ü¶ a * u x) :=
  (OrderIso.mulLeft‚ÇÄ a ha).isBoundedUnder_ge_comp.mpr hu

-- Mathlib.Topology.Algebra.Order.LiminfLimsup
-- #find_home IsBoundedUnder_ge_mul_left‚ÇÄ

end IsBounded


section Analysis

-- Need to generalize to other limits than 1(?)
-- summability comes from easier facts
variable {u v : ‚Ñï ‚Üí ‚Ñù} {a : ‚Ñù} (ha : 0 < a) (h_main : Tendsto (u / v) atTop (ùìù a))
  (h_sum : ‚àÄ ‚¶És‚¶Ñ, (1:‚Ñù) < s ‚Üí Summable (fun k ‚Ü¶ v k ^ s))
  (h_res : Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, v k ^ s) (ùìù[>] 1) (ùìù 1))

theorem tendsto_mul_tsum_of_tendsto_mul_tsum_aux (hu : ‚àÄ k, 0 ‚â§ u k) (hv : ‚àÄ k, 0 < v k) {Œµ : ‚Ñù}
    (hŒµ : 0 < Œµ) (hŒµ' : Œµ ‚â§ a) :
    ‚àÉ t : Finset ‚Ñï, ‚àÄ ‚¶És‚¶Ñ, (1:‚Ñù) < s ‚Üí
      (s - 1) * ‚àë k in t, u k ^ s + (a - Œµ) ^ s * ((s - 1) * ‚àë' (k : {k // k ‚àâ t}), v k ^ s) ‚â§
      (s - 1) * ‚àë' k, u k ^ s ‚àß
      (s - 1) * ‚àë' k, u k ^ s ‚â§
      (s - 1) * ‚àë k in t, u k ^ s + (a + Œµ) ^ s * ((s - 1) * ‚àë' (k : {k // k ‚àâ t}), v k ^ s) := by
  have h_sum' : ‚àÄ ‚¶És : ‚Ñù‚¶Ñ, 1 < s ‚Üí Summable (fun k ‚Ü¶ (u k) ^ s) := by
    sorry
  rsuffices ‚ü®k‚ÇÄ, hk‚ÇÄ‚ü© : ‚àÉ k‚ÇÄ, ‚àÄ k ‚â• k‚ÇÄ, ‚àÄ ‚¶És : ‚Ñù‚¶Ñ, 1 < s ‚Üí
      (a - Œµ) ^ s * v k ^ s ‚â§ u k ^ s ‚àß u k ^ s ‚â§ (a + Œµ) ^ s * v k ^ s := by
    obtain ‚ü®k‚ÇÄ, hk‚ÇÄ‚ü© := Metric.tendsto_atTop.mp h_main Œµ hŒµ
    refine ‚ü®k‚ÇÄ, fun k hk s hs ‚Ü¶ ?_‚ü©
    -- We remind Lean of some facts so that positivity works later on
    have : 0 < v k := hv k
    have : 0 ‚â§ u k := hu k
    have : 0 ‚â§ a - Œµ := sub_nonneg_of_le hŒµ'
    rw [‚Üê Real.mul_rpow, ‚Üê Real.mul_rpow, Real.rpow_le_rpow_iff, Real.rpow_le_rpow_iff, sub_mul,
      add_mul, ‚Üê sub_le_iff_le_add', sub_eq_add_neg, ‚Üê le_sub_iff_add_le', ‚Üê neg_mul,
      ‚Üê div_le_iff, ‚Üê le_div_iff, sub_div, mul_div_cancel_right‚ÇÄ, ‚Üê abs_le]
    exact le_of_lt (hk‚ÇÄ k hk)
    any_goals positivity
  refine ‚ü®Finset.Iio k‚ÇÄ, fun s hs ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ rw [mul_left_comm, ‚Üê mul_add, mul_le_mul_left (sub_pos.mpr hs),
      ‚Üê sum_add_tsum_subtype_compl (h_sum' hs), add_le_add_iff_left, ‚Üê tsum_mul_left]
    refine tsum_mono ?_ ?_ (fun ‚ü®k, hk‚ü© ‚Ü¶ ?_)
    ¬∑ exact Summable.mul_left _ (Summable.subtype (h_sum hs) _)
    ¬∑ exact Summable.subtype (h_sum' hs) _
    ¬∑ exact (hk‚ÇÄ k (not_lt.mp (Finset.mem_Iio.not.mp hk)) hs).1
  ¬∑ rw [mul_left_comm, ‚Üê mul_add, mul_le_mul_left (sub_pos.mpr hs),
      ‚Üê sum_add_tsum_subtype_compl (h_sum' hs), add_le_add_iff_left, ‚Üê tsum_mul_left]
    refine tsum_mono ?_ ?_ (fun ‚ü®k, hk‚ü© ‚Ü¶ ?_)
    ¬∑ exact Summable.subtype (h_sum' hs) _
    ¬∑ exact Summable.mul_left _ (Summable.subtype (h_sum hs) _)
    ¬∑ exact (hk‚ÇÄ k (not_lt.mp (Finset.mem_Iio.not.mp hk)) hs).2

theorem toto {a b : ‚Ñï ‚Üí ‚Ñù} {l : ‚Ñù}
    (ha : Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, a k ^ s) (ùìù[>] 1) (ùìù l))
    (has : ‚àÄ ‚¶És‚¶Ñ, (1:‚Ñù) < s ‚Üí Summable (fun k ‚Ü¶ a k ^ s))
    (h : ‚àÄ·∂† k in atTop, b k = a k) :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, b k ^ s) (ùìù[>] 1) (ùìù l) := by
  have hbs : ‚àÄ ‚¶És‚¶Ñ, (1:‚Ñù) < s ‚Üí Summable (fun k ‚Ü¶ b k ^ s) := by
    intro s hs
    refine (IsEquivalent.summable_iff_nat ?_).mp (has hs)
    refine EventuallyEq.isEquivalent ?_
    filter_upwards [h] with _ h using by rw [h]
  obtain ‚ü®k‚ÇÄ, hk‚ÇÄ‚ü© := eventually_atTop.mp h
  have : ‚àÄ·∂† (s:‚Ñù) in ùìù[>] 1, (s - 1) * ‚àë k in Finset.Iio k‚ÇÄ, (b k ^ s - a k ^ s) +
      (s - 1) * ‚àë' k, a k ^ s = (s - 1) * ‚àë' k, b k ^ s := by
    rw [eventually_nhdsWithin_iff]
    filter_upwards
    intro s hs
    rw [‚Üê mul_add]
    rw [mul_right_inj']
    rw [ Finset.sum_sub_distrib]
    rw [‚Üê sum_add_tsum_subtype_compl (has hs) (Finset.Iio k‚ÇÄ)]
    rw [‚Üê add_assoc]
    rw [sub_add_cancel]
    rw [‚Üê sum_add_tsum_subtype_compl (hbs hs) (Finset.Iio k‚ÇÄ)]
    rw [add_right_inj]
    refine tsum_congr (fun ‚ü®k, hk‚ü© ‚Ü¶ ?_)
    have := not_lt.mp (Finset.mem_Iio.not.mp hk)
    have := hk‚ÇÄ k (not_lt.mp (Finset.mem_Iio.not.mp hk))
    exact (congr_arg (¬∑ ^ s) (hk‚ÇÄ k (not_lt.mp (Finset.mem_Iio.not.mp hk)))).symm
    rw [sub_ne_zero]
    refine ne_of_gt ?_
    exact hs
  refine Filter.Tendsto.congr' this ?_
  convert Tendsto.add (a := 0) ?_ ha
  ¬∑ rw [zero_add]
  ¬∑ have : Tendsto (fun s : ‚Ñù ‚Ü¶ s - 1) (ùìù[>] 1) (ùìù 0) := by
      refine Tendsto.mono_left ?_ nhdsWithin_le_nhds
      refine tendsto_sub_nhds_zero_iff.mpr ?_
      exact tendsto_id
    convert Tendsto.mul this (tendsto_finset_sum (a := fun k ‚Ü¶ b k ^ (1:‚Ñù) - a k ^ (1:‚Ñù))
      (Finset.Iio k‚ÇÄ) fun k _ ‚Ü¶ ?_)
    ¬∑ rw [zero_mul]
    ¬∑ refine Tendsto.sub ?_ ?_
      ¬∑ refine Tendsto.mono_left ?_ nhdsWithin_le_nhds
        exact Real.continuousAt_const_rpow' one_ne_zero
      ¬∑ refine Tendsto.mono_left ?_ nhdsWithin_le_nhds
        exact Real.continuousAt_const_rpow' one_ne_zero

theorem tendsto_mul_tsum_of_tendsto_mul_tsum' (hu : ‚àÄ k, 0 ‚â§ u k) (hv : ‚àÄ k, 0 < v k) :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, u k ^ s) (ùìù[>] 1) (ùìù a) := by
  -- We first need to prove some basic facts
  have h_lim_eq_self : ‚àÄ x : ‚Ñù, Tendsto (fun s : ‚Ñù ‚Ü¶ x ^ s) (ùìù[>] 1) (ùìù x) := fun x ‚Ü¶ by
    convert Tendsto.rpow tendsto_const_nhds (tendsto_id.mono_left nhdsWithin_le_nhds)
      (Or.inr zero_lt_one)
    rw [Real.rpow_one]
  have h_tendsto_zero : ‚àÄ (w : ‚Ñï ‚Üí ‚Ñù) (t : Finset ‚Ñï),
      Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë k in t, w k ^ s) (ùìù[>] 1) (ùìù 0) := fun w t ‚Ü¶ by
    convert Tendsto.mul (a := 0) ?_ (tendsto_finset_sum t fun k _ ‚Ü¶ h_lim_eq_self (w k))
    ¬∑ rw [zero_mul]
    ¬∑ exact (tendsto_sub_nhds_zero_iff.mpr tendsto_id).mono_left nhdsWithin_le_nhds
  have h_tendsto_one : ‚àÄ (t : Finset ‚Ñï),
      Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' (k : {k // k ‚àâ t}), v k ^ s) (ùìù[>] 1) (ùìù 1) := fun t ‚Ü¶ by
    refine tendsto_nhdsWithin_congr (fun s hs ‚Ü¶ ?_) <| (sub_zero (1:‚Ñù)) ‚ñ∏
      Tendsto.sub h_res (h_tendsto_zero v t)
    rw [ ‚Üê sum_add_tsum_subtype_compl (h_sum hs) t, mul_add, add_sub_cancel_left]
  have h_bdu_le : ‚àÄ (Œµ : ‚Ñù) (t : Finset ‚Ñï),
      IsBoundedUnder (¬∑ ‚â§ ¬∑) (ùìù[>] 1) fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë k in t, u k ^ s +
        (a + Œµ) ^ s * ((s - 1) * ‚àë' (k : { k // k ‚àâ t }), v k ^ s) := fun Œµ t ‚Ü¶ by
    sorry
    -- refine IsBoundedUnder_le_add (h_tendsto_zero u t).isBoundedUnder_le ?_
    -- exact (Tendsto.mul (h_lim_eq_self (1 + Œµ)) (h_tendsto_one t)).isBoundedUnder_le
  have h_bdu_ge : ‚àÄ (Œµ : ‚Ñù) (t : Finset ‚Ñï),
      IsBoundedUnder (¬∑ ‚â• ¬∑) (ùìù[>] 1) fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë k in t, u k ^ s +
        (a - Œµ) ^ s * ((s - 1) * ‚àë' (k : { k // k ‚àâ t }), v k ^ s) := fun Œµ t ‚Ü¶ by
    sorry
    -- refine IsBoundedUnder_ge_add (h_tendsto_zero u t).isBoundedUnder_ge ?_
    -- exact (Tendsto.mul (h_lim_eq_self (1 - Œµ)) (h_tendsto_one t)).isBoundedUnder_ge
  have h_Œµbdd : ‚àÄ·∂† (Œµ : ‚Ñù) in ùìù[>] 0, 0 < Œµ ‚àß Œµ ‚â§ a :=
    eventually_iff_exists_mem.mpr ‚ü®Set.Ioc 0 a, Ioc_mem_nhdsWithin_Ioi' ha, fun _ h ‚Ü¶ h‚ü©
  -- We then prove bounds on liminf and limsup
  have h_bdd : ‚àÄ ‚¶ÉŒµ : ‚Ñù‚¶Ñ, 0 < Œµ ‚Üí Œµ ‚â§ a ‚Üí
      a - Œµ ‚â§ liminf (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, u k ^ s) (ùìù[>] 1) ‚àß
        limsup (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, u k ^ s) (ùìù[>] 1) ‚â§ a + Œµ := fun Œµ hŒµ hŒµ' ‚Ü¶ by
    obtain ‚ü®t, ht‚ü© := tendsto_mul_tsum_of_tendsto_mul_tsum_aux ha h_main h_sum hu hv hŒµ hŒµ'
    have h‚ÇÅ : ‚àÄ·∂† (s : ‚Ñù) in ùìù[>] 1, _ := eventually_nhdsWithin_of_forall (fun s hs ‚Ü¶ (ht hs).1)
    have h‚ÇÇ : ‚àÄ·∂† (s : ‚Ñù) in ùìù[>] 1, _ := eventually_nhdsWithin_of_forall (fun s hs ‚Ü¶ (ht hs).2)
    refine ‚ü®?_, ?_‚ü©
    ¬∑ convert liminf_le_liminf h‚ÇÅ (h_bdu_ge Œµ t) ?_
      ¬∑ refine (Tendsto.liminf_eq ?_).symm
        simp_rw [show ùìù (a - Œµ) = ùìù (0 + (a - Œµ) * 1) by ring_nf]
        exact (h_tendsto_zero u t).add  <| Tendsto.mul (h_lim_eq_self (a - Œµ)) (h_tendsto_one t)
      ¬∑ exact IsBounded.isCobounded_ge <| IsBoundedUnder.mono_le (h_bdu_le Œµ t) h‚ÇÇ
    ¬∑ convert limsup_le_limsup h‚ÇÇ ?_ (h_bdu_le Œµ t)
      ¬∑ refine (Tendsto.limsup_eq ?_).symm
        simp_rw [show ùìù (a + Œµ) = ùìù (0 + (a + Œµ) * 1) by ring_nf]
        exact (h_tendsto_zero u t).add  <| Tendsto.mul (h_lim_eq_self (a + Œµ)) (h_tendsto_one t)
      ¬∑ exact IsBounded.isCobounded_le <| IsBoundedUnder.mono_ge (h_bdu_ge Œµ t) h‚ÇÅ
  -- Finally we get the result by proving that liminf and limsup are equal
  obtain ‚ü®t, ht‚ü© := tendsto_mul_tsum_of_tendsto_mul_tsum_aux ha h_main h_sum hu hv ha le_rfl
  refine tendsto_of_le_liminf_of_limsup_le ?_ ?_ ?_ ?_
  ¬∑ refine le_of_frequently_sub_le (Eventually.frequently ?_)
    filter_upwards [h_Œµbdd] with Œµ ‚ü®hŒµ, hŒµ'‚ü© using (h_bdd hŒµ hŒµ').1
  ¬∑ refine le_of_frequently_le_add (Eventually.frequently ?_)
    filter_upwards [h_Œµbdd] with Œµ ‚ü®hŒµ, hŒµ'‚ü© using (h_bdd hŒµ hŒµ').2
  ¬∑ sorry
    -- exact (h_bdu_le 1 t).mono_le  (eventually_nhdsWithin_of_forall fun s hs ‚Ü¶ (ht hs).2)
  ¬∑ sorry
    -- exact (h_bdu_ge 1 t).mono_ge  (eventually_nhdsWithin_of_forall fun s hs ‚Ü¶ (ht hs).1)

theorem tendsto_mul_tsum_of_tendsto_mul_tsum (hv : ‚àÄ·∂† k in atTop, 0 < v k) :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, u k ^ s) (ùìù[>] 1) (ùìù a) := by
  have hu : ‚àÄ·∂† k in atTop, 0 ‚â§ u k := by
    rw [Metric.tendsto_nhds] at h_main
    specialize h_main 1 zero_lt_one
    filter_upwards [h_main, hv] with k h‚ÇÅ h‚ÇÇ
    rw [Pi.div_apply] at h‚ÇÅ
    rw [Real.dist_eq, abs_lt] at h‚ÇÅ
    rw [lt_tsub_iff_left] at h‚ÇÅ
    -- rw [add_neg_self] at h‚ÇÅ
    -- rw [div_pos_iff_of_pos_right h‚ÇÇ] at h‚ÇÅ
    -- exact le_of_lt h‚ÇÅ.1
    sorry
  obtain ‚ü®kv, hkv‚ü© := eventually_atTop.mp hv
  obtain ‚ü®ku, hku‚ü© := eventually_atTop.mp hu
  let v' : ‚Ñï ‚Üí ‚Ñù := fun k ‚Ü¶ if kv ‚â§ k then v k else 1
  let u' : ‚Ñï ‚Üí ‚Ñù := fun k ‚Ü¶ if ku ‚â§ k then u k else 1
  have hv' : ‚àÄ k, 0 < v' k := by
    intro k
    dsimp only [v']
    split_ifs with h
    ¬∑ exact hkv k h
    ¬∑ norm_num
  have hu' : ‚àÄ k, 0 ‚â§ u' k := by
    intro k
    dsimp only [u']
    split_ifs with h
    ¬∑ exact hku k h
    ¬∑ norm_num
  have hvv' : ‚àÄ·∂† k in atTop, v' k = v k := by
    rw [eventually_atTop]
    refine ‚ü®kv, ?_‚ü©
    intro k h
    dsimp only [v']
    rw [if_pos h]
  have huu' : ‚àÄ·∂† k in atTop, u k = u' k := by
    rw [eventually_atTop]
    refine ‚ü®ku, ?_‚ü©
    intro k h
    dsimp only [u']
    rw [if_pos h]
  have h_main' : Tendsto (u' / v') atTop (ùìù a) := by
    refine Tendsto.congr' ?_ h_main
    filter_upwards [hvv', huu'] with _ h‚ÇÅ h‚ÇÇ using by simp_rw [Pi.div_apply, h‚ÇÅ, h‚ÇÇ]
  have h_sum' : ‚àÄ ‚¶És‚¶Ñ, (1:‚Ñù) < s ‚Üí Summable (fun k ‚Ü¶ (v' k) ^ s) := by
    intro s hs
    refine (IsEquivalent.summable_iff_nat ?_).mp (h_sum hs)
    refine EventuallyEq.isEquivalent ?_
    filter_upwards [hvv'] with _ h using by rw [h]
  have h_res' : Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, v' k ^ s) (ùìù[>] 1) (ùìù 1) := by
    exact toto h_res h_sum hvv'
  have := tendsto_mul_tsum_of_tendsto_mul_tsum' ha h_main' h_sum' h_res' hu' hv'

  refine toto this ?_ huu'
  intro s hs
  refine (IsEquivalent.summable_iff_nat ?_).mp (h_sum' hs)
  sorry -- too many similar proofs

end Analysis

/- section Analysis

-- Need to generalize to other limits than 1 / equivalent to a instead of 1?
-- summability comes from easier facts
variable {u v : ‚Ñï ‚Üí ‚Ñù} (h_main : Tendsto (u / v) atTop (ùìù 1))
  (h_sum : ‚àÄ ‚¶És‚¶Ñ, (1:‚Ñù) < s ‚Üí Summable (fun k ‚Ü¶ v k ^ s))
  (h_res : Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, v k ^ s) (ùìù[>] 1) (ùìù 1))

theorem tendsto_mul_tsum_of_tendsto_mul_tsum_aux (hu : ‚àÄ k, 0 ‚â§ u k) (hv : ‚àÄ k, 0 < v k) {Œµ : ‚Ñù}
    (hŒµ : 0 < Œµ) (hŒµ' : Œµ ‚â§ 1) :
    ‚àÉ t : Finset ‚Ñï, ‚àÄ ‚¶És‚¶Ñ, (1:‚Ñù) < s ‚Üí
      (s - 1) * ‚àë k in t, u k ^ s + (1 - Œµ) ^ s * ((s - 1) * ‚àë' (k : {k // k ‚àâ t}), v k ^ s) ‚â§
      (s - 1) * ‚àë' k, u k ^ s ‚àß
      (s - 1) * ‚àë' k, u k ^ s ‚â§
      (s - 1) * ‚àë k in t, u k ^ s + (1 + Œµ) ^ s * ((s - 1) * ‚àë' (k : {k // k ‚àâ t}), v k ^ s) := by
  have h_sum' : ‚àÄ ‚¶És : ‚Ñù‚¶Ñ, 1 < s ‚Üí Summable (fun k ‚Ü¶ (u k) ^ s) := by
    refine fun s hs ‚Ü¶ (IsEquivalent.summable_iff_nat ?_).mpr (h_sum hs)
    refine (isEquivalent_iff_tendsto_one (eventually_of_forall (fun _ ‚Ü¶ ?_))).mpr ?_
    ¬∑ refine (Real.rpow_eq_zero (le_of_lt (hv _)) (by linarith)).not.mpr <| ne_of_gt (hv _)
    ¬∑ convert Tendsto.congr (fun _ ‚Ü¶ ?_)
        (Tendsto.comp (Real.continuousAt_rpow_const 1 s (Or.inl one_ne_zero)) h_main)
      ¬∑ simp_rw [Real.one_rpow]
      ¬∑ rw [Function.comp_apply, Pi.div_apply, Pi.div_apply, Real.div_rpow (hu _) (le_of_lt (hv _))]
  rsuffices ‚ü®k‚ÇÄ, hk‚ÇÄ‚ü© : ‚àÉ k‚ÇÄ, ‚àÄ k ‚â• k‚ÇÄ, ‚àÄ ‚¶És : ‚Ñù‚¶Ñ, 1 < s ‚Üí
      (1 - Œµ) ^ s * v k ^ s ‚â§ u k ^ s ‚àß u k ^ s ‚â§ (1 + Œµ) ^ s * v k ^ s := by
    obtain ‚ü®k‚ÇÄ, hk‚ÇÄ‚ü© := Metric.tendsto_atTop.mp h_main Œµ hŒµ
    refine ‚ü®k‚ÇÄ, fun k hk s hs ‚Ü¶ ?_‚ü©
    -- We remind Lean of some facts so that positivity works later on
    have : 0 < v k := hv k
    have : 0 ‚â§ u k := hu k
    have : 0 ‚â§ 1 - Œµ := sub_nonneg_of_le hŒµ'
    rw [‚Üê Real.mul_rpow, ‚Üê Real.mul_rpow, Real.rpow_le_rpow_iff, Real.rpow_le_rpow_iff, sub_mul,
      add_mul, one_mul, ‚Üê sub_le_iff_le_add', sub_eq_add_neg, ‚Üê le_sub_iff_add_le', ‚Üê neg_mul,
      ‚Üê div_le_iff, ‚Üê le_div_iff, sub_div, div_self, ‚Üê abs_le]
    exact le_of_lt (hk‚ÇÄ k hk)
    any_goals positivity
  refine ‚ü®Finset.Iio k‚ÇÄ, fun s hs ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ rw [mul_left_comm, ‚Üê mul_add, mul_le_mul_left (sub_pos.mpr hs),
      ‚Üê sum_add_tsum_subtype_compl (h_sum' hs), add_le_add_iff_left, ‚Üê tsum_mul_left]
    refine tsum_mono ?_ ?_ (fun ‚ü®k, hk‚ü© ‚Ü¶ ?_)
    ¬∑ exact Summable.mul_left _ (Summable.subtype (h_sum hs) _)
    ¬∑ exact Summable.subtype (h_sum' hs) _
    ¬∑ exact (hk‚ÇÄ k (not_lt.mp (Finset.mem_Iio.not.mp hk)) hs).1
  ¬∑ rw [mul_left_comm, ‚Üê mul_add, mul_le_mul_left (sub_pos.mpr hs),
      ‚Üê sum_add_tsum_subtype_compl (h_sum' hs), add_le_add_iff_left, ‚Üê tsum_mul_left]
    refine tsum_mono ?_ ?_ (fun ‚ü®k, hk‚ü© ‚Ü¶ ?_)
    ¬∑ exact Summable.subtype (h_sum' hs) _
    ¬∑ exact Summable.mul_left _ (Summable.subtype (h_sum hs) _)
    ¬∑ exact (hk‚ÇÄ k (not_lt.mp (Finset.mem_Iio.not.mp hk)) hs).2

theorem toto {a b : ‚Ñï ‚Üí ‚Ñù} (ha : Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, a k ^ s) (ùìù[>] 1) (ùìù 1))
    (has : ‚àÄ ‚¶És‚¶Ñ, (1:‚Ñù) < s ‚Üí Summable (fun k ‚Ü¶ a k ^ s))
    (h : ‚àÄ·∂† k in atTop, b k = a k) :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, b k ^ s) (ùìù[>] 1) (ùìù 1) := by
  have hbs : ‚àÄ ‚¶És‚¶Ñ, (1:‚Ñù) < s ‚Üí Summable (fun k ‚Ü¶ b k ^ s) := by
    intro s hs
    refine (IsEquivalent.summable_iff_nat ?_).mp (has hs)
    refine EventuallyEq.isEquivalent ?_
    filter_upwards [h] with _ h using by rw [h]
  obtain ‚ü®k‚ÇÄ, hk‚ÇÄ‚ü© := eventually_atTop.mp h
  have : ‚àÄ·∂† (s:‚Ñù) in ùìù[>] 1, (s - 1) * ‚àë k in Finset.Iio k‚ÇÄ, (b k ^ s - a k ^ s) +
      (s - 1) * ‚àë' k, a k ^ s = (s - 1) * ‚àë' k, b k ^ s := by
    rw [eventually_nhdsWithin_iff]
    filter_upwards
    intro s hs
    rw [‚Üê mul_add]
    rw [mul_right_inj']
    rw [ Finset.sum_sub_distrib]
    rw [‚Üê sum_add_tsum_subtype_compl (has hs) (Finset.Iio k‚ÇÄ)]
    rw [‚Üê add_assoc]
    rw [sub_add_cancel]
    rw [‚Üê sum_add_tsum_subtype_compl (hbs hs) (Finset.Iio k‚ÇÄ)]
    rw [add_right_inj]
    refine tsum_congr (fun ‚ü®k, hk‚ü© ‚Ü¶ ?_)
    have := not_lt.mp (Finset.mem_Iio.not.mp hk)
    have := hk‚ÇÄ k (not_lt.mp (Finset.mem_Iio.not.mp hk))
    exact (congr_arg (¬∑ ^ s) (hk‚ÇÄ k (not_lt.mp (Finset.mem_Iio.not.mp hk)))).symm
    rw [sub_ne_zero]
    refine ne_of_gt ?_
    exact hs
  refine Filter.Tendsto.congr' this ?_
  convert Tendsto.add (a := 0) ?_ ha
  ¬∑ rw [zero_add]
  ¬∑ have : Tendsto (fun s : ‚Ñù ‚Ü¶ s - 1) (ùìù[>] 1) (ùìù 0) := by
      refine Tendsto.mono_left ?_ nhdsWithin_le_nhds
      refine tendsto_sub_nhds_zero_iff.mpr ?_
      exact tendsto_id
    convert Tendsto.mul this (tendsto_finset_sum (a := fun k ‚Ü¶ b k ^ (1:‚Ñù) - a k ^ (1:‚Ñù))
      (Finset.Iio k‚ÇÄ) fun k _ ‚Ü¶ ?_)
    ¬∑ rw [zero_mul]
    ¬∑ refine Tendsto.sub ?_ ?_
      ¬∑ refine Tendsto.mono_left ?_ nhdsWithin_le_nhds
        exact Real.continuousAt_const_rpow' one_ne_zero
      ¬∑ refine Tendsto.mono_left ?_ nhdsWithin_le_nhds
        exact Real.continuousAt_const_rpow' one_ne_zero

theorem tendsto_mul_tsum_of_tendsto_mul_tsum' (hu : ‚àÄ k, 0 ‚â§ u k) (hv : ‚àÄ k, 0 < v k) :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, u k ^ s) (ùìù[>] 1) (ùìù 1) := by
  -- We first need to prove some basic facts
  have h_lim_eq_self : ‚àÄ x : ‚Ñù, Tendsto (fun s : ‚Ñù ‚Ü¶ x ^ s) (ùìù[>] 1) (ùìù x) := fun x ‚Ü¶ by
    convert Tendsto.rpow tendsto_const_nhds (tendsto_id.mono_left nhdsWithin_le_nhds)
      (Or.inr zero_lt_one)
    rw [Real.rpow_one]
  have h_tendsto_zero : ‚àÄ (w : ‚Ñï ‚Üí ‚Ñù) (t : Finset ‚Ñï),
      Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë k in t, w k ^ s) (ùìù[>] 1) (ùìù 0) := fun w t ‚Ü¶ by
    convert Tendsto.mul (a := 0) ?_ (tendsto_finset_sum t fun k _ ‚Ü¶ h_lim_eq_self (w k))
    ¬∑ rw [zero_mul]
    ¬∑ exact (tendsto_sub_nhds_zero_iff.mpr tendsto_id).mono_left nhdsWithin_le_nhds
  have h_tendsto_one : ‚àÄ (t : Finset ‚Ñï),
      Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' (k : {k // k ‚àâ t}), v k ^ s) (ùìù[>] 1) (ùìù 1) := fun t ‚Ü¶ by
    refine tendsto_nhdsWithin_congr (fun s hs ‚Ü¶ ?_) <| (sub_zero (1:‚Ñù)) ‚ñ∏
      Tendsto.sub h_res (h_tendsto_zero v t)
    rw [ ‚Üê sum_add_tsum_subtype_compl (h_sum hs) t, mul_add, add_sub_cancel_left]
  have h_bdu_le : ‚àÄ (Œµ : ‚Ñù) (t : Finset ‚Ñï),
      IsBoundedUnder (¬∑ ‚â§ ¬∑) (ùìù[>] 1) fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë k in t, u k ^ s +
        (1 + Œµ) ^ s * ((s - 1) * ‚àë' (k : { k // k ‚àâ t }), v k ^ s) := fun Œµ t ‚Ü¶ by
    refine IsBoundedUnder_le_add (h_tendsto_zero u t).isBoundedUnder_le ?_
    exact (Tendsto.mul (h_lim_eq_self (1 + Œµ)) (h_tendsto_one t)).isBoundedUnder_le
  have h_bdu_ge : ‚àÄ (Œµ : ‚Ñù) (t : Finset ‚Ñï),
      IsBoundedUnder (¬∑ ‚â• ¬∑) (ùìù[>] 1) fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë k in t, u k ^ s +
        (1 - Œµ) ^ s * ((s - 1) * ‚àë' (k : { k // k ‚àâ t }), v k ^ s) := fun Œµ t ‚Ü¶ by
    refine IsBoundedUnder_ge_add (h_tendsto_zero u t).isBoundedUnder_ge ?_
    exact (Tendsto.mul (h_lim_eq_self (1 - Œµ)) (h_tendsto_one t)).isBoundedUnder_ge
  have h_Œµbdd : ‚àÄ·∂† (Œµ : ‚Ñù) in ùìù[>] 0, 0 < Œµ ‚àß Œµ ‚â§ 1 :=
    eventually_iff_exists_mem.mpr ‚ü®Set.Ioc 0 1, Ioc_mem_nhdsWithin_Ioi' zero_lt_one, fun _ h ‚Ü¶ h‚ü©
  -- We then prove bounds on liminf and limsup
  have h_bdd : ‚àÄ ‚¶ÉŒµ : ‚Ñù‚¶Ñ, 0 < Œµ ‚Üí Œµ ‚â§ 1 ‚Üí
      1 - Œµ ‚â§ liminf (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, u k ^ s) (ùìù[>] 1) ‚àß
        limsup (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, u k ^ s) (ùìù[>] 1) ‚â§ 1 + Œµ := fun Œµ hŒµ hŒµ' ‚Ü¶ by
    obtain ‚ü®t, ht‚ü© := tendsto_mul_tsum_of_tendsto_mul_tsum_aux h_main h_sum hu hv hŒµ hŒµ'
    have h‚ÇÅ : ‚àÄ·∂† (s : ‚Ñù) in ùìù[>] 1, _ := eventually_nhdsWithin_of_forall (fun s hs ‚Ü¶ (ht hs).1)
    have h‚ÇÇ : ‚àÄ·∂† (s : ‚Ñù) in ùìù[>] 1, _ := eventually_nhdsWithin_of_forall (fun s hs ‚Ü¶ (ht hs).2)
    refine ‚ü®?_, ?_‚ü©
    ¬∑ convert liminf_le_liminf h‚ÇÅ (h_bdu_ge Œµ t) ?_
      ¬∑ refine (Tendsto.liminf_eq ?_).symm
        simp_rw [show ùìù (1 - Œµ) = ùìù (0 + (1 - Œµ) * 1) by ring_nf]
        exact (h_tendsto_zero u t).add  <| Tendsto.mul (h_lim_eq_self (1 - Œµ)) (h_tendsto_one t)
      ¬∑ exact IsBounded.isCobounded_ge <| IsBoundedUnder.mono_le (h_bdu_le Œµ t) h‚ÇÇ
    ¬∑ convert limsup_le_limsup h‚ÇÇ ?_ (h_bdu_le Œµ t)
      ¬∑ refine (Tendsto.limsup_eq ?_).symm
        simp_rw [show ùìù (1 + Œµ) = ùìù (0 + (1 + Œµ) * 1) by ring_nf]
        exact (h_tendsto_zero u t).add  <| Tendsto.mul (h_lim_eq_self (1 + Œµ)) (h_tendsto_one t)
      ¬∑ exact IsBounded.isCobounded_le <| IsBoundedUnder.mono_ge (h_bdu_ge Œµ t) h‚ÇÅ
  -- Finally we get the result by proving that liminf and limsup are equal
  obtain ‚ü®t, ht‚ü© := tendsto_mul_tsum_of_tendsto_mul_tsum_aux h_main h_sum hu hv zero_lt_one le_rfl
  refine tendsto_of_le_liminf_of_limsup_le ?_ ?_ ?_ ?_
  ¬∑ refine le_of_frequently_sub_le (Eventually.frequently ?_)
    filter_upwards [h_Œµbdd] with Œµ ‚ü®hŒµ, hŒµ'‚ü© using (h_bdd hŒµ hŒµ').1
  ¬∑ refine le_of_frequently_le_add (Eventually.frequently ?_)
    filter_upwards [h_Œµbdd] with Œµ ‚ü®hŒµ, hŒµ'‚ü© using (h_bdd hŒµ hŒµ').2
  ¬∑ exact (h_bdu_le 1 t).mono_le  (eventually_nhdsWithin_of_forall fun s hs ‚Ü¶ (ht hs).2)
  ¬∑ exact (h_bdu_ge 1 t).mono_ge  (eventually_nhdsWithin_of_forall fun s hs ‚Ü¶ (ht hs).1)

theorem tendsto_mul_tsum_of_tendsto_mul_tsum (hv : ‚àÄ·∂† k in atTop, 0 < v k) :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, u k ^ s) (ùìù[>] 1) (ùìù 1) := by
  have hu : ‚àÄ·∂† k in atTop, 0 ‚â§ u k := by
    rw [Metric.tendsto_nhds] at h_main
    specialize h_main 1 zero_lt_one
    filter_upwards [h_main, hv] with k h‚ÇÅ h‚ÇÇ
    rw [Pi.div_apply] at h‚ÇÅ
    rw [Real.dist_eq, abs_lt] at h‚ÇÅ
    rw [lt_tsub_iff_left] at h‚ÇÅ
    rw [add_neg_self] at h‚ÇÅ
    rw [div_pos_iff_of_pos_right h‚ÇÇ] at h‚ÇÅ
    exact le_of_lt h‚ÇÅ.1
  obtain ‚ü®kv, hkv‚ü© := eventually_atTop.mp hv
  obtain ‚ü®ku, hku‚ü© := eventually_atTop.mp hu
  let v' : ‚Ñï ‚Üí ‚Ñù := fun k ‚Ü¶ if kv ‚â§ k then v k else 1
  let u' : ‚Ñï ‚Üí ‚Ñù := fun k ‚Ü¶ if ku ‚â§ k then u k else 1
  have hv' : ‚àÄ k, 0 < v' k := by
    intro k
    dsimp only [v']
    split_ifs with h
    ¬∑ exact hkv k h
    ¬∑ norm_num
  have hu' : ‚àÄ k, 0 ‚â§ u' k := by
    intro k
    dsimp only [u']
    split_ifs with h
    ¬∑ exact hku k h
    ¬∑ norm_num
  have hvv' : ‚àÄ·∂† k in atTop, v' k = v k := by
    rw [eventually_atTop]
    refine ‚ü®kv, ?_‚ü©
    intro k h
    dsimp only [v']
    rw [if_pos h]
  have huu' : ‚àÄ·∂† k in atTop, u k = u' k := by
    rw [eventually_atTop]
    refine ‚ü®ku, ?_‚ü©
    intro k h
    dsimp only [u']
    rw [if_pos h]
  have h_main' : Tendsto (u' / v') atTop (ùìù 1) := by
    refine Tendsto.congr' ?_ h_main
    filter_upwards [hvv', huu'] with _ h‚ÇÅ h‚ÇÇ using by simp_rw [Pi.div_apply, h‚ÇÅ, h‚ÇÇ]
  have h_sum' : ‚àÄ ‚¶És‚¶Ñ, (1:‚Ñù) < s ‚Üí Summable (fun k ‚Ü¶ (v' k) ^ s) := by
    intro s hs
    refine (IsEquivalent.summable_iff_nat ?_).mp (h_sum hs)
    refine EventuallyEq.isEquivalent ?_
    filter_upwards [hvv'] with _ h using by rw [h]
  have h_res' : Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' k, v' k ^ s) (ùìù[>] 1) (ùìù 1) := by
    exact toto h_res h_sum hvv'
  have := tendsto_mul_tsum_of_tendsto_mul_tsum' h_main' h_sum' h_res' hu' hv'
  refine toto this ?_ huu'
  intro s hs
  refine (IsEquivalent.summable_iff_nat ?_).mp (h_sum' hs)
  sorry -- too many similar proofs

end Analysis -/

section Box

theorem BoxIntegral.Box.IsBounded_Icc {Œπ : Type*} [Fintype Œπ] (B : BoxIntegral.Box Œπ) :
    Bornology.IsBounded (BoxIntegral.Box.Icc B) := B.isCompact_Icc.isBounded

theorem BoxIntegral.Box.IsBounded {Œπ : Type*} [Fintype Œπ] (B : BoxIntegral.Box Œπ) :
    Bornology.IsBounded B.toSet :=
  Bornology.IsBounded.subset (BoxIntegral.Box.IsBounded_Icc B) coe_subset_Icc

end Box

noncomputable section

namespace BoxIntegral

open Bornology MeasureTheory Fintype Submodule

variable {Œπ : Type*} (n : ‚Ñï+)

def UnitBoxPart (ŒΩ : Œπ ‚Üí ‚Ñ§) : BoxIntegral.Box Œπ where
  lower := fun i ‚Ü¶ ŒΩ i / n
  upper := fun i ‚Ü¶ ŒΩ i / n + 1 / n
  lower_lt_upper := fun _ ‚Ü¶ by norm_num

@[simp]
theorem UnitBoxPart_mem {ŒΩ : Œπ ‚Üí ‚Ñ§} {x : Œπ ‚Üí ‚Ñù} :
    x ‚àà UnitBoxPart n ŒΩ ‚Üî ‚àÄ i, ŒΩ i / n < x i ‚àß x i ‚â§ ŒΩ i / n + 1 / n := by
  simp_rw [BoxIntegral.Box.mem_def, UnitBoxPart, Set.mem_Ioc]

def UnitBoxIndex (x : Œπ ‚Üí ‚Ñù) : Œπ ‚Üí ‚Ñ§ := fun i ‚Ü¶ Int.ceil (n * x i) - 1

@[simp]
theorem UnitBoxIndex_apply {x : Œπ ‚Üí ‚Ñù} (i : Œπ) :
    UnitBoxIndex n x i = Int.ceil (n * (x : Œπ ‚Üí ‚Ñù) i) - 1 := rfl

variable {n} in
theorem UnitBoxPart_mem_iff_index_eq {x : Œπ ‚Üí ‚Ñù} {ŒΩ : Œπ ‚Üí ‚Ñ§} :
    x ‚àà UnitBoxPart n ŒΩ ‚Üî UnitBoxIndex n x = ŒΩ := by
  rw [UnitBoxPart_mem, Function.funext_iff]
  have h_npos : 0 < (n:‚Ñù) := Nat.cast_pos.mpr <| PNat.pos n
  simp_rw [UnitBoxIndex_apply n, sub_eq_iff_eq_add, Int.ceil_eq_iff, Int.cast_add, Int.cast_one,
    add_sub_cancel_right, ‚Üê _root_.le_div_iff' h_npos, ‚Üê div_lt_iff' h_npos, add_div]

-- Upper right corner
def UnitBoxTag (ŒΩ : Œπ ‚Üí ‚Ñ§) : Œπ ‚Üí ‚Ñù := fun i ‚Ü¶ (ŒΩ i + 1) / n

theorem UnitBoxTag_injective : Function.Injective (fun ŒΩ : Œπ ‚Üí ‚Ñ§ ‚Ü¶ UnitBoxTag n ŒΩ) := by
  intro _ _ h
  ext i
  have := congr_arg (fun x ‚Ü¶ x i) h
  dsimp [UnitBoxTag] at this
  field_simp at this
  exact this

theorem UnitBoxTag_mem_unitBoxPart (ŒΩ : Œπ ‚Üí ‚Ñ§) :
    UnitBoxTag n ŒΩ ‚àà UnitBoxPart n ŒΩ := by
  simp_rw [Box.mem_def, UnitBoxTag, UnitBoxPart, Set.mem_Ioc]
  refine fun _ ‚Ü¶ ‚ü®?_, by rw [‚Üê add_div]‚ü©
  rw [div_lt_div_right <| Nat.cast_pos.mpr (PNat.pos n)]
  linarith

@[simp]
theorem UnitBoxIndex_tag (ŒΩ : Œπ ‚Üí ‚Ñ§) :
    UnitBoxIndex n (UnitBoxTag n ŒΩ) = ŒΩ := by
  rw [‚Üê UnitBoxPart_mem_iff_index_eq]
  exact UnitBoxTag_mem_unitBoxPart n ŒΩ

theorem UnitBoxPart_disjoint {ŒΩ ŒΩ' : Œπ ‚Üí ‚Ñ§} :
    ŒΩ ‚â† ŒΩ' ‚Üî Disjoint (UnitBoxPart n ŒΩ).toSet (UnitBoxPart n ŒΩ').toSet := by
  rw [not_iff_not.symm, ne_eq, not_not, Set.not_disjoint_iff]
  simp_rw [Box.mem_coe]
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®x, hx, hx'‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ exact ‚ü®UnitBoxTag n ŒΩ, UnitBoxTag_mem_unitBoxPart n ŒΩ, h ‚ñ∏ UnitBoxTag_mem_unitBoxPart n ŒΩ‚ü©
  ¬∑ rw [‚Üê UnitBoxPart_mem_iff_index_eq.mp hx, ‚Üê UnitBoxPart_mem_iff_index_eq.mp hx']

theorem UnitBoxPart_injective : Function.Injective (fun ŒΩ : Œπ ‚Üí ‚Ñ§ ‚Ü¶ UnitBoxPart n ŒΩ) := by
  intro _ _ h
  contrapose! h
  rw [UnitBoxPart_disjoint] at h
  exact Box.ne_of_disjoint_coe h

variable [Fintype Œπ]

theorem UnitBoxPart_diam (ŒΩ : Œπ ‚Üí ‚Ñ§) :
    Metric.diam (BoxIntegral.Box.Icc (UnitBoxPart n ŒΩ)) ‚â§ 1 / n := by
  refine ENNReal.toReal_le_of_le_ofReal (by positivity) ?_
  rw [BoxIntegral.Box.Icc_eq_pi]
  refine EMetric.diam_pi_le_of_le (fun i ‚Ü¶ ?_)
  rw [Real.ediam_Icc, UnitBoxPart, add_sub_cancel_left, ENNReal.ofReal_div_of_pos,
    ENNReal.ofReal_one]
  exact Nat.cast_pos.mpr n.pos

@[simp]
theorem UnitBoxPart_volume (ŒΩ : Œπ ‚Üí ‚Ñ§) :
    volume (UnitBoxPart n ŒΩ : Set (Œπ ‚Üí ‚Ñù)) = 1 / n ^ card Œπ := by
  simp_rw [volume_pi, BoxIntegral.Box.coe_eq_pi, Measure.pi_pi, Real.volume_Ioc, UnitBoxPart,
    add_sub_cancel_left]
  rw [Finset.prod_const, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr n.pos), ENNReal.ofReal_one,
    ENNReal.ofReal_coe_nat, Finset.card_univ, one_div, one_div, ENNReal.inv_pow]

theorem UnitBoxIndex_setFinite_of_finite_measure {s : Set (Œπ ‚Üí ‚Ñù)} (hm : NullMeasurableSet s)
    (hs : volume s ‚â† ‚ä§) :
    Set.Finite {ŒΩ : Œπ ‚Üí ‚Ñ§ | ‚Üë(UnitBoxPart n ŒΩ) ‚äÜ s} := by
  have := Measure.finite_const_le_meas_of_disjoint_iUnion‚ÇÄ
    (volume : Measure (Œπ ‚Üí ‚Ñù)) (Œµ := 1 / n ^ card Œπ) (by norm_num)
    (As := fun ŒΩ : Œπ ‚Üí ‚Ñ§ ‚Ü¶ (UnitBoxPart n ŒΩ) ‚à© s) ?_ ?_ ?_
  ¬∑ refine this.subset ?_
    intro ŒΩ hŒΩ
    rw [Set.mem_setOf, Set.inter_eq_self_of_subset_left hŒΩ, UnitBoxPart_volume]
  ¬∑ intro ŒΩ
    refine NullMeasurableSet.inter ?_ hm
    exact (UnitBoxPart n ŒΩ).measurableSet_coe.nullMeasurableSet
  ¬∑ intro ŒΩ ŒΩ' h
    have := (UnitBoxPart_disjoint n).mp h
    refine Disjoint.aedisjoint ?_
    rw [Set.disjoint_iff_inter_eq_empty]
    dsimp only
    rw [Set.inter_inter_inter_comm]
    rw [Set.disjoint_iff_inter_eq_empty] at this
    rw [this]
    rw [Set.empty_inter]
  ¬∑ rw [‚Üê lt_top_iff_ne_top]
    refine measure_lt_top_of_subset ?_ hs
    aesop

def UnitBoxIndexAdmissible (B : Box Œπ) : Finset (Œπ ‚Üí ‚Ñ§) := by
  let A := {ŒΩ : Œπ ‚Üí ‚Ñ§ | UnitBoxPart n ŒΩ ‚â§ B}
  refine Set.Finite.toFinset (s := A) ?_
  refine UnitBoxIndex_setFinite_of_finite_measure n ?_ ?_
  ¬∑ exact B.measurableSet_coe.nullMeasurableSet
  ¬∑ rw [‚Üê lt_top_iff_ne_top]
    refine IsBounded.measure_lt_top ?_
    exact Box.IsBounded B

variable {n} in
theorem UnitBoxIndexAdmissible_iff {B : Box Œπ} {ŒΩ : Œπ ‚Üí ‚Ñ§} :
    ŒΩ ‚àà UnitBoxIndexAdmissible n B ‚Üî UnitBoxPart n ŒΩ ‚â§ B := by
  rw [UnitBoxIndexAdmissible, Set.Finite.mem_toFinset, Set.mem_setOf_eq]

open Classical in
def UnitBoxTaggedPrepartition (B : Box Œπ) : BoxIntegral.TaggedPrepartition B where
  boxes := Finset.image (fun ŒΩ ‚Ü¶ UnitBoxPart n ŒΩ) (UnitBoxIndexAdmissible n B)
  le_of_mem' _ hB := by
    obtain ‚ü®_, hŒΩ, rfl‚ü© := Finset.mem_image.mp hB
    exact UnitBoxIndexAdmissible_iff.mp hŒΩ
  pairwiseDisjoint := by
    intro _ hB _ hB' h
    obtain ‚ü®_, _, rfl‚ü© := Finset.mem_image.mp hB
    obtain ‚ü®_, _, rfl‚ü© := Finset.mem_image.mp hB'
    exact (UnitBoxPart_disjoint n).mp fun h' ‚Ü¶ h (congrArg (UnitBoxPart n) h')
  tag := by
    intro B'
    by_cases hB' : ‚àÉ ŒΩ ‚àà UnitBoxIndexAdmissible n B, B' = UnitBoxPart n ŒΩ
    ¬∑ exact UnitBoxTag n hB'.choose
    ¬∑ exact B.exists_mem.choose
  tag_mem_Icc := by
    intro B'
    split_ifs with hB'
    ¬∑ have := hB'.choose_spec.1
      rw [UnitBoxIndexAdmissible_iff] at this
      refine Box.coe_subset_Icc ?_
      refine this ?_
      exact UnitBoxTag_mem_unitBoxPart n (Exists.choose hB')
    ¬∑ exact Box.coe_subset_Icc (B.exists_mem.choose_spec)

variable {n} in
@[simp]
theorem UnitBoxTaggedPrepartition_mem_iff {B B' : Box Œπ} :
    B' ‚àà UnitBoxTaggedPrepartition n B ‚Üî
      ‚àÉ ŒΩ ‚àà UnitBoxIndexAdmissible n B, UnitBoxPart n ŒΩ = B' := by
  classical
  rw [UnitBoxTaggedPrepartition, TaggedPrepartition.mem_mk, Prepartition.mem_mk, Finset.mem_image]

theorem UnitBoxTaggedPrepartition_tag_eq {ŒΩ : Œπ ‚Üí ‚Ñ§} (B : Box Œπ)
    (hŒΩ : ŒΩ ‚àà UnitBoxIndexAdmissible n B) :
    (UnitBoxTaggedPrepartition n B).tag (UnitBoxPart n ŒΩ) = UnitBoxTag n ŒΩ := by
  dsimp only [UnitBoxTaggedPrepartition]
  have h : ‚àÉ ŒΩ' ‚àà UnitBoxIndexAdmissible n B, UnitBoxPart n ŒΩ = UnitBoxPart n ŒΩ' := ‚ü®ŒΩ, hŒΩ, rfl‚ü©
  rw [dif_pos h, (UnitBoxTag_injective n).eq_iff, ‚Üê (UnitBoxPart_injective n).eq_iff]
  exact h.choose_spec.2.symm

theorem UnitBoxTaggedPrepartition_isHenstock (B : Box Œπ) :
    (UnitBoxTaggedPrepartition n B).IsHenstock := by
  intro _ hB
  obtain ‚ü®ŒΩ, hŒΩ, rfl‚ü© := UnitBoxTaggedPrepartition_mem_iff.mp hB
  rw [UnitBoxTaggedPrepartition_tag_eq n B hŒΩ]
  exact BoxIntegral.Box.coe_subset_Icc (UnitBoxTag_mem_unitBoxPart n ŒΩ)

def HasIntegralVertices (B : Box Œπ) : Prop :=
  ‚àÉ l u : Œπ ‚Üí ‚Ñ§, (‚àÄ i, B.lower i = l i) ‚àß (‚àÄ i, B.upper i = u i)

variable {n} in
theorem UnitBoxIndex_memAdmissible_iff' {x : Œπ ‚Üí ‚Ñù} {B : Box Œπ} :
  UnitBoxIndex n x ‚àà UnitBoxIndexAdmissible n B ‚Üî
    ‚àÄ i, n * B.lower i + 1 ‚â§ Int.ceil (n * x i) ‚àß Int.ceil (n * x i) ‚â§ n * B.upper i  := by
  simp_rw [UnitBoxIndexAdmissible_iff, Box.le_iff_bounds, UnitBoxPart, UnitBoxIndex, Pi.le_def,
    ‚Üê forall_and]
  have : (0:‚Ñù) < n := Nat.cast_pos.mpr n.pos
  simp_rw [Int.cast_sub, Int.cast_one, ‚Üê add_div, le_div_iff' this, div_le_iff' this,
    sub_add_cancel, le_sub_iff_add_le]

theorem UnixBoxIndexAdmissible_of_mem_box {B : Box Œπ} (hB : HasIntegralVertices B)
    {x : Œπ ‚Üí ‚Ñù} (hx : x ‚àà B) :
    UnitBoxIndex n x ‚àà UnitBoxIndexAdmissible n B := by
  obtain ‚ü®l, u, hl, hu‚ü© := hB
  rw [UnitBoxIndex_memAdmissible_iff']
  intro i
  rw [hl i, hu i, show ((n : ‚Ñï) : ‚Ñù) = (n : ‚Ñ§) by rfl, ‚Üê Int.cast_mul, ‚Üê Int.cast_mul,
    ‚Üê Int.cast_one, ‚Üê Int.cast_add, Int.cast_le, Int.cast_le, Int.ceil_le]
  rw [Int.add_one_le_ceil_iff, Int.cast_mul, Int.cast_mul, mul_lt_mul_left, _root_.mul_le_mul_left]
  simp_rw [Box.mem_def, Set.mem_Ioc, hl, hu] at hx
  exact hx i
  exact Nat.cast_pos.mpr n.pos
  exact Nat.cast_pos.mpr n.pos

theorem UnitBoxPart_index_mem {B : Box Œπ} (hB : HasIntegralVertices B) {x : Œπ ‚Üí ‚Ñù} (hx : x ‚àà B) :
    UnitBoxPart n (UnitBoxIndex n x) ‚àà UnitBoxTaggedPrepartition n B := by
  rw [UnitBoxTaggedPrepartition_mem_iff]
  refine ‚ü®UnitBoxIndex n x, ?_, rfl‚ü©
  exact UnixBoxIndexAdmissible_of_mem_box n hB hx

theorem UnitBoxTaggedPrepartition_isPartition {B : Box Œπ} (hB : HasIntegralVertices B) :
    (UnitBoxTaggedPrepartition n B).IsPartition := by
  intro x hx
  use UnitBoxPart n (UnitBoxIndex n x)
  refine ‚ü®?_, ?_‚ü©
  ¬∑ rw [BoxIntegral.TaggedPrepartition.mem_toPrepartition, UnitBoxTaggedPrepartition_mem_iff]
    refine ‚ü®UnitBoxIndex n x, ?_, rfl‚ü©
    exact UnixBoxIndexAdmissible_of_mem_box n hB hx
  ¬∑ exact UnitBoxPart_mem_iff_index_eq.mpr rfl

theorem UnitBoxTaggedPrepartition_isSubordinate (B : Box Œπ) {r : ‚Ñù} (hr : 0 < r) (hn : 1 / r ‚â§ n) :
    (UnitBoxTaggedPrepartition n B).IsSubordinate (fun _ ‚Ü¶ ‚ü®r, hr‚ü©) := by
  intro _ hB
  obtain ‚ü®ŒΩ, hŒΩ, rfl‚ü© := UnitBoxTaggedPrepartition_mem_iff.mp hB
  dsimp
  have t1 : Metric.diam (Box.Icc (UnitBoxPart n ŒΩ)) ‚â§ r := by
    refine le_trans (UnitBoxPart_diam n ŒΩ) ?_
    rw [div_le_iff]
    rwa [div_le_iff hr, mul_comm] at hn
    exact Nat.cast_pos.mpr n.pos
  intro x hx
  rw [Metric.mem_closedBall, UnitBoxTaggedPrepartition_tag_eq n B hŒΩ]
  have t2 : UnitBoxTag n ŒΩ ‚àà (BoxIntegral.Box.Icc (UnitBoxPart n ŒΩ)) := by
    refine Box.coe_subset_Icc ?_
    exact UnitBoxTag_mem_unitBoxPart _ _
  have t3 := Metric.dist_le_diam_of_mem ?_ hx t2
  exact le_trans t3 t1
  refine IsCompact.isBounded ?_
  exact BoxIntegral.Box.isCompact_Icc (UnitBoxPart n ŒΩ)

theorem le_hasIntegralVertices_of_isBounded {Œπ : Type*} [Finite Œπ] {s : Set (Œπ ‚Üí ‚Ñù)}
    (h : IsBounded s) :
    ‚àÉ B : BoxIntegral.Box Œπ, HasIntegralVertices B ‚àß s ‚â§ B := by
  have := Fintype.ofFinite Œπ
  obtain ‚ü®R, hR‚ÇÅ, hR‚ÇÇ‚ü© := Bornology.IsBounded.subset_ball_lt h 0 0
  let C : ‚Ñï+ := ‚ü®Nat.ceil R, Nat.ceil_pos.mpr hR‚ÇÅ‚ü©
  refine ‚ü®?_, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ refine BoxIntegral.Box.mk (fun _ ‚Ü¶ - C) (fun _ ‚Ü¶ C ) ?_
    intro _
    norm_num [hR‚ÇÅ]
  ¬∑ exact fun _ ‚Ü¶ - C
  ¬∑ exact fun _ ‚Ü¶ C
  ¬∑ simp
  ¬∑ intro x hx
    have t1 : Metric.ball (0 : Œπ ‚Üí ‚Ñù) R ‚äÜ Metric.ball 0 C := by
      refine Metric.ball_subset_ball ?h
      exact Nat.le_ceil R
    have := hR‚ÇÇ hx
    have := t1 this
    rw [mem_ball_zero_iff] at this
    rw [pi_norm_lt_iff] at this
    ¬∑ simp_rw [Real.norm_eq_abs, abs_lt] at this
      simp only [Box.mem_coe, Box.mem_mk, Set.mem_Ioc]
      refine fun i ‚Ü¶ ‚ü®?_, ?_‚ü©
      ¬∑ exact (this i).1
      ¬∑ exact le_of_lt (this i).2
    ¬∑ refine lt_of_lt_of_le hR‚ÇÅ ?_
      exact Nat.le_ceil R

open scoped Pointwise

variable (c : ‚Ñù) (s : Set (Œπ ‚Üí ‚Ñù))

-- abbrev IntegralPoints (c : ‚Ñù) : Set (Œπ ‚Üí ‚Ñù) := c ‚Ä¢ s ‚à© span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ))

-- -- Only keep this version and just prove the equiv with the other one if necessary
abbrev IntegralPoints : Set (Œπ ‚Üí ‚Ñù) := s ‚à© c‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ))

variable (F : (Œπ ‚Üí ‚Ñù) ‚Üí ‚Ñù) (hF : Continuous F)

open scoped BigOperators

-- This is really slow...
theorem Fintype_integralPoints (hs‚ÇÄ : IsBounded s) : Fintype (IntegralPoints c s) := by
  by_cases hc : c = 0
  ¬∑ rw [hc, IntegralPoints, inv_zero]
    rw [‚Üê coe_pointwise_smul]
    rw [zero_smul]
    rw [zero_eq_bot, bot_coe]
    exact ofFinite _
  ¬∑ have : DiscreteTopology (c‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ))).toAddSubgroup := by
      change DiscreteTopology (c‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ)) : Set (Œπ ‚Üí ‚Ñù))
      let e : (Œπ ‚Üí ‚Ñù) ‚âÉ‚Çú (Œπ ‚Üí ‚Ñù) := Homeomorph.smulOfNeZero c hc
      convert DiscreteTopology.preimage_of_continuous_injective
        (s := (span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ)) : Set (Œπ ‚Üí ‚Ñù))) e.continuous e.injective using 2
      all_goals
      ¬∑ ext
        rw [Homeomorph.smulOfNeZero_apply, Set.mem_preimage, SetLike.mem_coe,
          Set.mem_inv_smul_set_iff‚ÇÄ hc, SetLike.mem_coe]
    rw [IntegralPoints]
    refine Set.Finite.fintype ?_
    convert @Metric.finite_isBounded_inter_isClosed _ _ _ _ _ this hs‚ÇÄ _
    exact AddSubgroup.isClosed_of_discrete

def CountingFunction := Nat.card (IntegralPoints c s)

-- Probably inline that instead (and others too?)
abbrev SeriesFunction := ‚àë' x : IntegralPoints c s, F x

-- theorem IntegralPoints_mem_iff {x : Œπ ‚Üí ‚Ñù} :
--     x ‚àà IntegralPoints s n ‚Üî (n:‚Ñù)‚Åª¬π ‚Ä¢ x ‚àà IntegralPoints' Œπ s n := by
--   simp only [Set.mem_inter_iff, SetLike.mem_coe, ne_eq, Nat.cast_eq_zero, PNat.ne_zero,
--     not_false_eq_true, ‚Üê Set.mem_smul_set_iff_inv_smul_mem‚ÇÄ, smul_inv_smul‚ÇÄ]

-- def IntegralPointsEquiv : IntegralPoints Œπ s n ‚âÉ IntegralPoints' Œπ s n := by
--   refine Equiv.ofBijective ?_ ‚ü®?_, ?_‚ü©
--   ¬∑ rintro ‚ü®x, hx‚ü©
--     exact ‚ü®(n:‚Ñù)‚Åª¬π ‚Ä¢ x, (IntegralPoints_mem_iff Œπ n s).mp hx‚ü©
--   ¬∑ intro _ _ h
--     have := congr_arg ((n:‚Ñù) ‚Ä¢ ¬∑) (Subtype.mk_eq_mk.mp h)
--     simpa [smul_inv_smul‚ÇÄ, SetCoe.ext_iff, this]
--   ¬∑ rintro ‚ü®y, hy‚ü©
--     refine ‚ü®‚ü®((n:‚Ñù) ‚Ä¢ y), ?_‚ü©, ?_‚ü©
--     ¬∑ simpa only [IntegralPoints_mem_iff, ne_eq, Nat.cast_eq_zero, PNat.ne_zero, not_false_eq_true,
--       inv_smul_smul‚ÇÄ]
--     ¬∑ simp only [ne_eq, Nat.cast_eq_zero, PNat.ne_zero, not_false_eq_true, inv_smul_smul‚ÇÄ]

-- theorem IntegralPointsEquiv_apply (x : IntegralPoints s n) :
--     (IntegralPointsEquiv Œπ n s x : Œπ ‚Üí ‚Ñù) = (n:‚Ñù)‚Åª¬π ‚Ä¢ x := rfl

-- theorem IntegralPointsEquiv_symm_apply (x : IntegralPoints' Œπ s n) :
--     ((IntegralPointsEquiv Œπ n s).symm x : Œπ ‚Üí ‚Ñù) = (n:‚Ñù) ‚Ä¢ x := by
--   have := IntegralPointsEquiv_apply Œπ n s ((IntegralPointsEquiv Œπ n s).symm x)
--   simp only [Equiv.apply_symm_apply] at this
--   rw [this]
--   simp

theorem UnitBoxTag_mem_smul_span (ŒΩ : Œπ ‚Üí ‚Ñ§) :
    UnitBoxTag n ŒΩ ‚àà (n:‚Ñù)‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ)) := by
  simp_rw [‚Üê SetLike.mem_coe, coe_pointwise_smul, Set.mem_smul_set, SetLike.mem_coe,
    Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, algebraMap_int_eq, Int.coe_castRingHom,
    Set.mem_range]
  refine ‚ü®?_, ?_‚ü©
  ¬∑ exact fun i ‚Ü¶ ŒΩ i + 1
  ¬∑ refine ‚ü®?_, ?_‚ü©
    ¬∑ intro i
      use ŒΩ i + 1
      zify
    ¬∑ ext i
      rw [Pi.smul_apply, smul_eq_mul, UnitBoxTag]
      ring

theorem UnitBoxTag_eq_of_mem_smul_span {x : Œπ ‚Üí ‚Ñù}
    (hx : x ‚àà (n:‚Ñù)‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ))) :
    UnitBoxTag n (UnitBoxIndex n x) = x := by
  simp_rw [‚Üê SetLike.mem_coe, coe_pointwise_smul, Set.mem_smul_set, SetLike.mem_coe,
    Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, algebraMap_int_eq, Int.coe_castRingHom,
    Set.mem_range] at hx
  obtain ‚ü®ŒΩ, hŒΩ, rfl‚ü© := hx
  ext i
  obtain ‚ü®y, hy‚ü© := hŒΩ i
  rw [UnitBoxTag, UnitBoxIndex, Pi.smul_apply, ‚Üê hy, smul_eq_mul, ‚Üê mul_assoc, mul_inv_cancel,
    one_mul, Int.cast_sub, Int.cast_one, sub_add_cancel]
  rw [Int.ceil_intCast]
  ring
  rw [Nat.cast_ne_zero]
  exact PNat.ne_zero n

theorem UnitBoxIndex_injective_of_mem {x y : Œπ ‚Üí ‚Ñù}
    (hx : x ‚àà (n:‚Ñù)‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ)))
    (hy : y ‚àà (n:‚Ñù)‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ)))
    (h : UnitBoxIndex n x = UnitBoxIndex n y) : x = y := by
  have := congr_arg (UnitBoxTag n ¬∑) h
  dsimp only at this
  rwa [UnitBoxTag_eq_of_mem_smul_span n hx, UnitBoxTag_eq_of_mem_smul_span n hy] at this

theorem UnitBoxTaggedPrepartition_tag_mem {x : Œπ ‚Üí ‚Ñù} {B : Box Œπ} (hB : HasIntegralVertices B)
    (hs‚ÇÅ : s ‚â§ B) (hx : x ‚àà IntegralPoints n s) :
    (UnitBoxTaggedPrepartition n B).tag (UnitBoxPart n (UnitBoxIndex n x)) ‚àà s := by
  rw [UnitBoxTaggedPrepartition_tag_eq, UnitBoxTag_eq_of_mem_smul_span]
  ¬∑ exact hx.1
  ¬∑ exact hx.2
  ¬∑ refine UnixBoxIndexAdmissible_of_mem_box n hB ?_
    exact hs‚ÇÅ hx.1

theorem SeriesFunction_eq {B : Box Œπ} (hB : HasIntegralVertices B) (hs‚ÇÄ : s ‚â§ B) :
    ‚àë' x : IntegralPoints n s, F x =
      Finset.sum (UnitBoxTaggedPrepartition n B).toPrepartition.boxes
        fun C ‚Ü¶ (Set.indicator s F ((UnitBoxTaggedPrepartition n B).tag C)) := by
  classical
  -- have : Fintype (IntegralPoints s n) := by
  --   have : Fintype ((n:‚Ñù) ‚Ä¢ s ‚à© span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ)) : Set (Œπ ‚Üí ‚Ñù)) := sorry
  --   refine @Fintype.ofEquiv _ _ this ?_
  --   rw [IntegralPoints]

  --   refine Set.Finite.fintype ?_

  --   let T := (n:‚Ñù)‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ))
  --   have : DiscreteTopology ((n:‚Ñù)‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ)) : Set (Œπ ‚Üí ‚Ñù)) := by

  --     sorry
  --   refine Metric.finite_isBounded_inter_isClosed ?_ ?_
  --   -- refine Bornology.IsBounded.smul‚ÇÄ ?_ _
  --   -- have := UnitBox_isBounded Œπ A
  --   refine Bornology.IsBounded.subset ?_ hs‚ÇÅ
  --   exact Box.IsBounded B

  --   -- change IsClosed (span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ))).toAddSubgroup
  --   -- exact AddSubgroup.isClosed_of_discrete
  have : IsBounded s := by
    refine IsBounded.subset ?_ hs‚ÇÄ
    exact Box.IsBounded B
  have := Fintype_integralPoints n s this
  rw [tsum_fintype]
  rw [Finset.sum_indicator_eq_sum_filter]
  have : (n:‚Ñù) ‚â† 0 := by
    rw [Nat.cast_ne_zero]
    exact PNat.ne_zero n
  rw [Finset.sum_set_coe (IntegralPoints n s)]
  refine Finset.sum_nbij ?_ ?_ ?_ ?_ ?_
  ¬∑ exact fun x ‚Ü¶ UnitBoxPart n (UnitBoxIndex n x)
  ¬∑ simp_rw [Set.mem_toFinset, Finset.mem_filter]
    intro x hx
    -- have t1 := UnixBoxIndexAdmissible_of_mem_box n hB (hs‚ÇÅ hx.1)
    rw [BoxIntegral.Prepartition.mem_boxes, BoxIntegral.TaggedPrepartition.mem_toPrepartition]
    ¬∑ refine ‚ü®?_, ?_‚ü©
      ¬∑ refine UnitBoxPart_index_mem _ hB ?_
        exact hs‚ÇÄ hx.1
      ¬∑ rw [UnitBoxTaggedPrepartition_tag_eq]
        rw [UnitBoxTag_eq_of_mem_smul_span]
        exact hx.1
        exact hx.2
        exact UnixBoxIndexAdmissible_of_mem_box n hB (hs‚ÇÄ hx.1)
  ¬∑ simp_rw [Set.coe_toFinset]
    intro x hx y hy h
    rw [(UnitBoxPart_injective n).eq_iff] at h
    exact UnitBoxIndex_injective_of_mem n hx.2 hy.2 h
  ¬∑ intro x hx
    rw [Finset.coe_filter, Set.mem_setOf_eq, BoxIntegral.Prepartition.mem_boxes,
      BoxIntegral.TaggedPrepartition.mem_toPrepartition, UnitBoxTaggedPrepartition_mem_iff] at hx
    obtain ‚ü®‚ü®ŒΩ, hŒΩ, rfl‚ü©, h‚ü© := hx
    refine ‚ü®?_, ?_, ?_‚ü©
    ¬∑ exact UnitBoxTag n ŒΩ
    ¬∑ rw [Set.coe_toFinset, Set.mem_inter_iff]
      refine ‚ü®?_, ?_‚ü©
      ¬∑ rwa [UnitBoxTaggedPrepartition_tag_eq] at h
        exact hŒΩ
      ¬∑ rw [‚Üê coe_pointwise_smul]
        exact UnitBoxTag_mem_smul_span n ŒΩ
    ¬∑ simp
  ¬∑ intro x hx
    rw [Set.mem_toFinset] at hx
    rw [UnitBoxTaggedPrepartition_tag_eq, UnitBoxTag_eq_of_mem_smul_span]
    ¬∑ exact hx.2
    ¬∑ exact UnixBoxIndexAdmissible_of_mem_box n hB (hs‚ÇÄ hx.1)

theorem UnitBoxTaggedPrepartition_integralSum' {B : Box Œπ} (hB : HasIntegralVertices B)
    (hs‚ÇÄ : s ‚â§ B) :
    BoxIntegral.integralSum (Set.indicator s F)
      (BoxIntegral.BoxAdditiveMap.toSMul (Measure.toBoxAdditive volume))
        (UnitBoxTaggedPrepartition n B) = (‚àë' x : IntegralPoints n s, F x) / n ^ card Œπ := by
  unfold BoxIntegral.integralSum
  rw [SeriesFunction_eq n s F hB hs‚ÇÄ, Finset.sum_div]
  refine Finset.sum_congr rfl ?_
  rintro _ hB
  rw [BoxIntegral.Prepartition.mem_boxes, BoxIntegral.TaggedPrepartition.mem_toPrepartition,
    UnitBoxTaggedPrepartition_mem_iff] at hB
  obtain ‚ü®_, _, rfl‚ü© := hB
  rw [BoxIntegral.BoxAdditiveMap.toSMul_apply, Measure.toBoxAdditive_apply, UnitBoxPart_volume,
    smul_eq_mul, mul_comm, ENNReal.toReal_div, ENNReal.one_toReal, ENNReal.toReal_pow,
    ENNReal.toReal_nat, mul_one_div]

theorem UnitBoxTaggedPrepartition_integralSum n {B : Box Œπ} (hB : HasIntegralVertices B)
    (hs‚ÇÄ : s ‚â§ B) :
    BoxIntegral.integralSum (Set.indicator s fun x ‚Ü¶ 1)
      (BoxIntegral.BoxAdditiveMap.toSMul (Measure.toBoxAdditive volume))
      (UnitBoxTaggedPrepartition n B) = (CountingFunction n s : ‚Ñù) / n ^ card Œπ := by
  convert UnitBoxTaggedPrepartition_integralSum' n s (fun _ ‚Ü¶ (1:‚Ñù)) hB hs‚ÇÄ
  rw [tsum_const, nsmul_eq_mul, mul_one, Nat.cast_inj]
  rfl

variable (hs‚ÇÅ : Bornology.IsBounded s) (hs‚ÇÇ : MeasurableSet s)

theorem main' :
    Tendsto (fun n : ‚Ñï ‚Ü¶ (‚àë' x : IntegralPoints n s, F x) / n ^ card Œπ)
      atTop (nhds (‚à´ x in s, F x)) := by
  obtain ‚ü®B, hB, hs‚ÇÄ‚ü© := le_hasIntegralVertices_of_isBounded hs‚ÇÅ
  obtain ‚ü®R, hR‚ÇÅ, hR‚ÇÇ‚ü© := Bornology.IsBounded.subset_ball_lt hs‚ÇÅ 0 0
  have : ContinuousOn (Set.indicator s (fun x ‚Ü¶ F x)) (BoxIntegral.Box.Icc B) := sorry
  have main := ContinuousOn.hasBoxIntegral (volume : Measure (Œπ ‚Üí ‚Ñù)) this
    BoxIntegral.IntegrationParams.Riemann
  rw [BoxIntegral.hasIntegral_iff] at main
  have : ‚à´ x in B, Set.indicator s F x = ‚à´ x in s, F x := by
    rw [MeasureTheory.integral_indicator hs‚ÇÇ]
    rw [Measure.restrict_restrict_of_subset hs‚ÇÄ]
  rw [this] at main

  rw [Metric.tendsto_atTop]
  intro eps h_eps
  specialize main (eps / 2) (half_pos h_eps)
  obtain ‚ü®r, hr‚ÇÅ, hr‚ÇÇ‚ü© := main
  specialize hr‚ÇÅ 0 rfl -- this say that ‚àÄ x, r x = r 0
  specialize hr‚ÇÇ 0
  let N : ‚Ñï+ := by
    refine ‚ü®?_, ?_‚ü©
    exact Nat.ceil (1 / (r 0 0 : ‚Ñù))
    rw [Nat.ceil_pos, one_div, inv_pos]
    exact (r 0 0).mem
  use N
  intro n hn
  have : ‚àÄ n, N ‚â§ n ‚Üí
      BoxIntegral.IntegrationParams.MemBaseSet BoxIntegral.IntegrationParams.Riemann
        B 0 (r 0) (UnitBoxTaggedPrepartition n B) := by
    intro n hn
    refine ‚ü®?_, ?_, ?_, ?_‚ü©
    ¬∑ have : r 0 = fun _ ‚Ü¶ r 0 0 := Function.funext_iff.mpr hr‚ÇÅ
      rw [this]
      refine UnitBoxTaggedPrepartition_isSubordinate _ _ _ ?_
      exact le_trans (Nat.le_ceil _) (Nat.cast_le.mpr hn)
    ¬∑ intro h
      simp [BoxIntegral.IntegrationParams.Riemann] at h
      exact UnitBoxTaggedPrepartition_isHenstock _ _
    ¬∑ intro h
      simp [BoxIntegral.IntegrationParams.Riemann] at h
    ¬∑ intro h
      simp [BoxIntegral.IntegrationParams.Riemann] at h
  have hn‚ÇÄ : 0 < n := lt_of_lt_of_le N.prop hn
  specialize hr‚ÇÇ _ (this ‚ü®n, hn‚ÇÄ‚ü© hn) (UnitBoxTaggedPrepartition_isPartition ‚ü®n, hn‚ÇÄ‚ü© hB)
  rw [UnitBoxTaggedPrepartition_integralSum'] at hr‚ÇÇ
  refine lt_of_le_of_lt hr‚ÇÇ ?_
  exact half_lt_self_iff.mpr h_eps
  exact hB
  exact hs‚ÇÄ

theorem main :
    Tendsto (fun n : ‚Ñï ‚Ü¶ (CountingFunction n s : ‚Ñù) / n ^ card Œπ)
      atTop (nhds (volume s).toReal) := by
  convert main' s (fun _ ‚Ü¶ 1) hs‚ÇÅ hs‚ÇÇ
  ¬∑ rw [tsum_const, nsmul_eq_mul, mul_one, Nat.cast_inj]
    rfl
  ¬∑ rw [set_integral_const, smul_eq_mul, mul_one]

end BoxIntegral

section Counting

variable {x : ‚Ñï ‚Üí ‚Ñù} (h‚ÇÅ : Monotone x) (h‚ÇÇ : Tendsto x atTop atTop) {l : ‚Ñù}
    (h‚ÇÉ : Tendsto (fun c : ‚Ñù ‚Ü¶ Nat.card {i | x i ‚â§ c} / c) atTop (ùìù l))

theorem lemma1 (B : ‚Ñù) : Set.Finite {i | x i ‚â§ B} := by
  simp_rw [show ‚àÄ i, x i ‚â§ B ‚Üî ¬¨ x i > B by aesop]
  rw [‚Üê Filter.eventually_cofinite, Nat.cofinite_eq_atTop]
  exact Tendsto.eventually_gt_atTop h‚ÇÇ B

theorem lemma2 :
    Tendsto (fun k ‚Ü¶ Nat.card {i | x i ‚â§ x k - 1} / x k) atTop (ùìù l) := by
  rw [tendsto_iff_seq_tendsto] at h‚ÇÉ
  specialize h‚ÇÉ (fun k ‚Ü¶ x k - 1) (tendsto_atTop_add_const_right atTop _ h‚ÇÇ)
  have : Tendsto (fun k ‚Ü¶ 1 - (x k)‚Åª¬π) atTop (ùìù 1) := by
    have t1 : Tendsto (fun k ‚Ü¶ - (x k)‚Åª¬π) atTop (ùìù 0) := by
      rw [show (0:‚Ñù) = - 0 from neg_zero.symm]
      exact h‚ÇÇ.inv_tendsto_atTop.neg
    convert Tendsto.const_add 1 t1 using 2
    rw [add_zero]
  refine Tendsto.congr' ?_ (mul_one l ‚ñ∏ (Tendsto.mul h‚ÇÉ this))
  have h‚ÇÑ : ‚àÄ·∂† k in atTop, x k - 1 ‚â† 0 :=
    (tendsto_atTop_add_const_right atTop _ h‚ÇÇ).eventually_ne_atTop _
  have h‚ÇÖ : ‚àÄ·∂† k in atTop, x k ‚â† 0 := h‚ÇÇ.eventually_ne_atTop _
  filter_upwards [h‚ÇÑ, h‚ÇÖ] with k hk hk'
  simp only [Set.coe_setOf, Function.comp_apply]
  rw [‚Üê one_div, one_sub_div hk', div_mul_div_cancel _ hk]

theorem lemma3 : Tendsto (fun k ‚Ü¶ (k + 1) / x k) atTop (ùìù l) := by
  have h‚ÇÖ : ‚àÄ·∂† k in atTop, 0 < x k := Tendsto.eventually_gt_atTop h‚ÇÇ _
  have lim‚ÇÅ := lemma2 h‚ÇÇ h‚ÇÉ
  have lim‚ÇÇ : Tendsto (fun k ‚Ü¶ Nat.card {i | x i ‚â§ x k} / x k) atTop (ùìù l) := by
    rw [tendsto_iff_seq_tendsto] at h‚ÇÉ
    specialize h‚ÇÉ (fun k ‚Ü¶ x k) h‚ÇÇ
    exact h‚ÇÉ
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le' lim‚ÇÅ lim‚ÇÇ ?_ ?_
  ¬∑ filter_upwards [h‚ÇÖ] with k hk
    rw [div_le_div_right hk,  ‚Üê Nat.cast_add_one, Nat.cast_le,
      show k + 1 = Nat.card (Set.Icc 0 k) by simp]
    refine Nat.card_mono ?_ ?_
    ¬∑ exact Set.finite_Icc 0 k
    ¬∑ intro i hi
      simp only [Set.mem_Icc, zero_le, true_and]
      contrapose! hi
      have := h‚ÇÅ (le_of_lt hi)
      simp
      refine lt_of_lt_of_le ?_ this
      norm_num
  ¬∑ filter_upwards [h‚ÇÖ] with k hk
    rw [div_le_div_right hk, ‚Üê Nat.cast_add_one, Nat.cast_le,
      show k + 1 = Nat.card (Set.Icc 0 k) by simp]
    refine Nat.card_mono ?_ ?_
    ¬∑ exact lemma1 h‚ÇÇ (x k)
    ¬∑ exact fun i hi ‚Ü¶ by
        simp only [Set.mem_setOf_eq]
        exact h‚ÇÅ hi.2

end Counting

noncomputable section general

open MeasureTheory MeasureTheory.Measure Submodule Filter Fintype

open scoped Pointwise

variable {E Œπ : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] (b : Basis Œπ ‚Ñù E)

variable (c : ‚Ñù) (s : Set E)

abbrev LatticePoints  : Set E := c ‚Ä¢ s ‚à© span ‚Ñ§ (Set.range b)

-- abbrev LatticePoints' (c : ‚Ñù) : Set E := s ‚à© c‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range b)

def LatticeCountingFunction := Nat.card (LatticePoints b c s)

variable [Fintype Œπ]

variable {c} in
def EquivIntegralPoints (hc : c ‚â† 0) :
    LatticePoints b c s ‚âÉ IntegralPoints c (b.equivFun '' s) := by
  let e := b.equivFun.toEquiv
  let f : (Œπ ‚Üí ‚Ñù) ‚âÉ (Œπ ‚Üí ‚Ñù) := MulAction.toPerm (Units.mk0 c‚Åª¬π (inv_ne_zero hc))
  let g := e.trans f
  refine g.subtypeEquiv ?_
  intro a
  simp [g, f, e, Set.mem_smul_set]
  refine ‚ü®fun ‚ü®‚ü®x, hxs, hxa‚ü©, h‚ÇÇ‚ü© ‚Ü¶ ‚ü®?_, ?_‚ü©, ?_‚ü©
  ¬∑ refine ‚ü®x, hxs, ?_‚ü©
    rw [‚Üê hxa]
    rw [LinearEquiv.map_smul]
    rw [Finsupp.coe_smul]
    rw [inv_smul_smul‚ÇÄ hc]
  ¬∑ refine ‚ü®?_, ?_, ?_‚ü©
    ¬∑ exact b.equivFun a
    ¬∑ rw [Basis.mem_span_iff_repr_mem] at h‚ÇÇ
      simp_rw [Basis.mem_span_iff_repr_mem, Basis.equivFun_apply, Pi.basisFun_repr]
      exact h‚ÇÇ
    ¬∑ simp
  ¬∑ rintro ‚ü®‚ü®x, hxs, hxa‚ü©, ‚ü®y, hy, hya‚ü©‚ü©
    refine ‚ü®?_, ?_‚ü©
    ¬∑ refine ‚ü®x, hxs, ?_‚ü©
      rw [eq_inv_smul_iff‚ÇÄ hc] at hxa
      rw [‚Üê Finsupp.coe_smul, ‚Üê LinearEquiv.map_smul] at hxa
      have : Function.Injective b.equivFun := by exact LinearEquiv.injective _
      exact this hxa
    ¬∑ rw [inv_smul_eq_iff‚ÇÄ hc] at hya
      rw [smul_inv_smul‚ÇÄ hc] at hya
      rw [Basis.mem_span_iff_repr_mem]
      simp_rw [Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, hya] at hy
      exact hy

theorem toto (hc : c ‚â† 0) : LatticeCountingFunction b c s = CountingFunction c (b.equivFun '' s) := by
  refine Nat.card_congr ?_
  exact EquivIntegralPoints b c s hc

variable [MeasurableSpace E] [BorelSpace E]

variable [DecidableEq Œπ] [DecidableEq (BoxIntegral.Box Œπ)]

theorem main2 (hs‚ÇÅ : Bornology.IsBounded s) (hs‚ÇÇ : MeasurableSet s) :
    Tendsto (fun n : ‚Ñï ‚Ü¶ (LatticeCountingFunction b n s : ‚Ñù) / n ^ card Œπ)
      atTop (ùìù (volume (b.equivFun '' s)).toReal) := by
  haveI : FiniteDimensional ‚Ñù E := FiniteDimensional.of_fintype_basis b
  refine Tendsto.congr' ?_ (main (b.equivFun '' s) ?_ ?_)
  ¬∑ filter_upwards [eventually_gt_atTop 0]
    intro c hc
    congr
    have := toto b c s ?_
    exact this.symm
    refine ne_of_gt ?_
    exact Nat.cast_pos.mpr hc
  ¬∑ rw [‚Üê NormedSpace.isVonNBounded_iff ‚Ñù] at hs‚ÇÅ ‚ä¢
    have := Bornology.IsVonNBounded.image (E := E) (F := Œπ ‚Üí ‚Ñù) (œÉ := RingHom.id ‚Ñù) hs‚ÇÅ
    erw [‚Üê LinearMap.coe_toContinuousLinearMap']
    exact this _
  ¬∑ rw [LinearEquiv.image_eq_preimage]
    have : Continuous b.equivFun.symm := by
      exact LinearMap.continuous_of_finiteDimensional _
    have : Measurable b.equivFun.symm := by
      exact Continuous.measurable this
    exact this hs‚ÇÇ

-- All these theorems should limits on ‚Ñï!!
theorem main2' :
    Tendsto (fun n : ‚Ñï ‚Ü¶ (LatticeCountingFunction b n s : ‚Ñù) / n ^ card Œπ)
      atTop (ùìù (volume (b.equivFun '' s)).toReal) := by sorry

variable (b‚ÇÄ : Basis Œπ ‚Ñù (Œπ ‚Üí ‚Ñù)) (s‚ÇÄ : Set (Œπ ‚Üí ‚Ñù)) (hs‚ÇÄ‚ÇÅ : Bornology.IsBounded s‚ÇÄ)
  (hs‚ÇÄ‚ÇÇ : MeasurableSet s‚ÇÄ)

theorem main3 :
    Tendsto (fun n : ‚Ñï ‚Ü¶ (LatticeCountingFunction b‚ÇÄ n s‚ÇÄ : ‚Ñù) / n ^ card Œπ)
      atTop (ùìù (|(LinearEquiv.det b‚ÇÄ.equivFun : ‚Ñù)| * (volume s‚ÇÄ).toReal)) := by
  convert main2 b‚ÇÄ s‚ÇÄ hs‚ÇÄ‚ÇÅ hs‚ÇÄ‚ÇÇ using 2
  rw [LinearEquiv.image_eq_preimage]
  rw [‚Üê MeasureTheory.Measure.map_apply‚ÇÄ]
  ¬∑ erw [Real.map_linearMap_volume_pi_eq_smul_volume_pi]
    ¬∑ rw [LinearEquiv.det_coe_symm, inv_inv]
      simp only [LinearEquiv.coe_det, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,
        smul_eq_mul, ENNReal.toReal_mul, abs_nonneg, ENNReal.toReal_ofReal]
    ¬∑ refine IsUnit.ne_zero ?_
      exact LinearEquiv.isUnit_det' _
  ¬∑ have : Continuous b‚ÇÄ.equivFun.symm := by
      exact LinearMap.continuous_of_finiteDimensional _
    exact Continuous.aemeasurable this
  ¬∑ exact MeasurableSet.nullMeasurableSet hs‚ÇÄ‚ÇÇ

end general

section cone

variable {E Œπ : Type*} [Fintype Œπ] [NormedAddCommGroup E] [NormedSpace ‚Ñù E] (b : Basis Œπ ‚Ñù E)

variable (X : Set E) (hX : ‚àÄ (x : E) (r : ‚Ñù), x ‚àà X ‚Üí 0 ‚â§ r ‚Üí r ‚Ä¢ x ‚àà X)

variable (F : E ‚Üí ‚Ñù) (hF‚ÇÅ : ‚àÄ (x : E) (r : ‚Ñù), 0 ‚â§ r ‚Üí  F (r ‚Ä¢ x) = r ^ card Œπ * (F x))
  (hF‚ÇÇ : IsBounded {x | F x ‚â§ 1})

abbrev ConePoints : Set E := X ‚à© span ‚Ñ§ (Set.range b)

example : Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' x : ConePoints b X, F x ^ (- s)) (ùìù[>] 1)
    (ùìù (volume (b.equivFun '' {x | F x ‚â§ 1})).toReal) := by

  have : (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' (n : ‚Ñï),
    (n ^ card Œπ / LatticeCountingFunction b n {x | F x ‚â§ 1} : ‚Ñù) ^ (- s))
      =·∂†[ùìù[>] 1] fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' x : ConePoints b X, F x ^ (- s) := by sorry
  refine Tendsto.congr' this ?_
  simp_rw [Real.rpow_neg sorry, ‚Üê Real.inv_rpow sorry]
  refine tendsto_mul_tsum_of_tendsto_mul_tsum (v := fun k ‚Ü¶ k) ?_ ?_ ?_ ?_ ?_
  ¬∑
    sorry
  ¬∑ have := main2' b {x | F x ‚â§ 1}
    sorry
  ¬∑ intro s hs
    sorry
  ¬∑ dsimp
    sorry
  ¬∑ sorry

end cone

#exit -------------------------------

set_option autoImplicit false

noncomputable section pi

open MeasureTheory Submodule Filter Fintype

open scoped Pointwise NNReal ENNReal

variable (Œπ : Type*) (A : ‚Ñï+)

def UnitBox : BoxIntegral.Box Œπ where
  lower := fun _ ‚Ü¶ -(A:‚Ñù)
  upper := fun _ ‚Ü¶ (A:‚Ñù)
  lower_lt_upper := fun _ ‚Ü¶ by norm_num

theorem UnitBox_mem (x : Œπ ‚Üí ‚Ñù) : x ‚àà UnitBox Œπ A ‚Üî ‚àÄ i, - A < x i ‚àß x i ‚â§ A := by
  simp_rw [BoxIntegral.Box.mem_def, UnitBox, Set.mem_Ioc]

theorem UnitBox_ball_le [Fintype Œπ] :
    Metric.ball 0 A ‚äÜ (UnitBox Œπ A).toSet := by
  simp_rw [ball_pi _ (Nat.cast_pos.mpr A.pos), BoxIntegral.Box.coe_eq_pi,
    Set.univ_pi_subset_univ_pi_iff, Real.ball_eq_Ioo, UnitBox, Pi.zero_apply, zero_sub, zero_add,
    Set.Ioo_subset_Ioc_self, implies_true, true_or]

theorem UnitBox_le_closedBall [Fintype Œπ] :
    (UnitBox Œπ A).toSet ‚äÜ Metric.closedBall 0 A := by
  simp_rw [closedBall_pi _ (Nat.cast_nonneg A), BoxIntegral.Box.coe_eq_pi,
    Set.univ_pi_subset_univ_pi_iff, Real.closedBall_eq_Icc, UnitBox, Pi.zero_apply, zero_sub,
    zero_add, Set.Ioc_subset_Icc_self, implies_true, true_or]

theorem UnitBox_isBounded [Finite Œπ] :
    Bornology.IsBounded (UnitBox Œπ A).toSet :=
  have := Fintype.ofFinite Œπ
  (Metric.isBounded_iff_subset_closedBall _).mpr ‚ü®_, UnitBox_le_closedBall Œπ A‚ü©

variable (n : ‚Ñï+)

def UnitBoxPart (ŒΩ : Œπ ‚Üí ‚Ñ§) : BoxIntegral.Box Œπ where
  lower := fun i ‚Ü¶ ŒΩ i / n
  upper := fun i ‚Ü¶ ŒΩ i / n + 1 / n
  lower_lt_upper := fun _ ‚Ü¶ by norm_num

theorem UnitBoxPart_mem {ŒΩ : Œπ ‚Üí ‚Ñ§} {x : Œπ ‚Üí ‚Ñù} :
    x ‚àà UnitBoxPart Œπ n ŒΩ ‚Üî ‚àÄ i, ŒΩ i / n < x i ‚àß x i ‚â§ ŒΩ i / n + 1 / n := by
  simp_rw [BoxIntegral.Box.mem_def, UnitBoxPart, Set.mem_Ioc]

def UnitBoxIndex (x : Œπ ‚Üí ‚Ñù) : Œπ ‚Üí ‚Ñ§ := fun i ‚Ü¶ Int.ceil (n * x i) - 1

theorem UnitBoxIndex_apply {x : Œπ ‚Üí ‚Ñù} (i : Œπ) :
    UnitBoxIndex Œπ n x i = Int.ceil (n * (x : Œπ ‚Üí ‚Ñù) i) - 1 := rfl

theorem UnitBoxPart_mem_iff_index_eq {x : Œπ ‚Üí ‚Ñù} {ŒΩ : Œπ ‚Üí ‚Ñ§} :
    x ‚àà UnitBoxPart Œπ n ŒΩ ‚Üî UnitBoxIndex Œπ n x = ŒΩ := by
  rw [UnitBoxPart_mem]
  rw [Function.funext_iff]
  have h_npos : 0 < (n:‚Ñù) := by
    rw [Nat.cast_pos]
    exact PNat.pos n
  simp_rw [UnitBoxIndex_apply Œπ n, sub_eq_iff_eq_add, Int.ceil_eq_iff, Int.cast_add, Int.cast_one,
    add_sub_cancel, ‚Üê _root_.le_div_iff' h_npos, ‚Üê div_lt_iff' h_npos, add_div]

-- Upper right corner
def UnitBoxTag (ŒΩ : Œπ ‚Üí ‚Ñ§) : Œπ ‚Üí ‚Ñù := fun i ‚Ü¶ (ŒΩ i + 1) / n

theorem UnitBoxTag_mem_unitBoxPart (ŒΩ : Œπ ‚Üí ‚Ñ§) :
    UnitBoxTag Œπ n ŒΩ ‚àà UnitBoxPart Œπ n ŒΩ := by
  simp_rw [BoxIntegral.Box.mem_def, UnitBoxTag, UnitBoxPart, Set.mem_Ioc]
  intro _
  refine ‚ü®?_, by rw [‚Üê add_div]‚ü©
  rw [div_lt_div_right <| Nat.cast_pos.mpr (PNat.pos n)]
  linarith

@[simp]
theorem UnitBoxIndex_tag (ŒΩ : Œπ ‚Üí ‚Ñ§) :
    UnitBoxIndex Œπ n (UnitBoxTag Œπ n ŒΩ) = ŒΩ := by
  rw [‚Üê UnitBoxPart_mem_iff_index_eq]
  exact UnitBoxTag_mem_unitBoxPart _ _ _

theorem UnitBoxTag_injective : Function.Injective (UnitBoxTag Œπ n) := by
  intro _ _ h
  ext i
  have := congr_arg (fun x ‚Ü¶ x i) h
  dsimp [UnitBoxTag] at this
  field_simp at this
  exact this

theorem UnitBoxPart_disjoint {ŒΩ ŒΩ' : Œπ ‚Üí ‚Ñ§} :
    ŒΩ ‚â† ŒΩ' ‚Üî Disjoint (UnitBoxPart Œπ n ŒΩ).toSet (UnitBoxPart Œπ n ŒΩ').toSet := by
  rw [not_iff_not.symm, ne_eq, not_not, Set.not_disjoint_iff]
  simp_rw [BoxIntegral.Box.mem_coe]
  refine ‚ü®?_, ?_‚ü©
  ¬∑ intro h
    exact ‚ü®UnitBoxTag Œπ n ŒΩ, UnitBoxTag_mem_unitBoxPart Œπ n ŒΩ, h ‚ñ∏ UnitBoxTag_mem_unitBoxPart Œπ n ŒΩ‚ü©
  ¬∑ rintro ‚ü®x, hx, hx'‚ü©
    rw [UnitBoxPart_mem_iff_index_eq] at hx
    rw [UnitBoxPart_mem_iff_index_eq] at hx'
    rw [‚Üê hx, ‚Üê hx']

theorem UnitBoxPart_injective : Function.Injective (UnitBoxPart Œπ n) := by
  intro _ _ h
  contrapose! h
  rw [UnitBoxPart_disjoint] at h
  exact BoxIntegral.Box.ne_of_disjoint_coe h

variable [Fintype Œπ] [DecidableEq Œπ] -- Use Finite instead so Decidable should not be necessary

theorem UnitBoxPart_diam (ŒΩ : Œπ ‚Üí ‚Ñ§) :
    Metric.diam (BoxIntegral.Box.Icc (UnitBoxPart Œπ n ŒΩ)) ‚â§ 1 / n := by
  rw [Metric.diam]
  refine ENNReal.toReal_le_of_le_ofReal (by positivity) ?_
  rw [BoxIntegral.Box.Icc_eq_pi]
  refine EMetric.diam_pi_le_of_le ?_
  intro i
  rw [Real.ediam_Icc, UnitBoxPart]
  rw [add_sub_cancel', ENNReal.ofReal_div_of_pos, ENNReal.ofReal_one]
  exact Nat.cast_pos.mpr n.pos

@[simp]
theorem UnitBoxPart_volume (ŒΩ : Œπ ‚Üí ‚Ñ§) :
    (volume (UnitBoxPart Œπ n ŒΩ : Set (Œπ ‚Üí ‚Ñù))).toReal = 1 / n ^ card Œπ := by
  simp_rw [volume_pi, BoxIntegral.Box.coe_eq_pi, Measure.pi_pi, Real.volume_Ioc]
  simp_rw [UnitBoxPart, add_sub_cancel']
  rw [Finset.prod_const, ENNReal.ofReal_div_of_pos, ENNReal.toReal_pow, ENNReal.toReal_div,
    div_pow, ENNReal.toReal_ofReal, ENNReal.toReal_ofReal, one_pow, Fintype.card]
  any_goals positivity
  exact Nat.cast_pos.mpr n.pos

def AdmissibleIndex :
  Finset (Œπ ‚Üí ‚Ñ§) := Fintype.piFinset (fun _ ‚Ü¶ Finset.Ico (n * - (A:‚Ñ§)) (n * A))

variable {Œπ A n} in
@[simp]
theorem UnitBoxIndex_admissible_iff {x : Œπ ‚Üí ‚Ñù} :
    UnitBoxIndex Œπ n x ‚àà AdmissibleIndex Œπ A n ‚Üî x ‚àà UnitBox Œπ A := by
  have h‚ÇÅ : 0 < (n:‚Ñù) := Nat.cast_pos.mpr n.pos
  have h‚ÇÇ : (n:‚Ñù) ‚â† 0 := Nat.cast_ne_zero.mpr n.ne_zero
  simp_rw [UnitBox_mem, AdmissibleIndex, mem_piFinset, Finset.mem_Ico, UnitBoxIndex_apply,
    Int.lt_iff_add_one_le, sub_add_cancel, le_sub_iff_add_le, ‚Üê Int.lt_iff_add_one_le, Int.lt_ceil,
    Int.ceil_le,  ‚Üê le_div_iff' h‚ÇÅ, ‚Üê div_lt_iff' h‚ÇÅ,  Int.cast_mul, mul_div_assoc,
    Int.cast_neg, Int.cast_ofNat, mul_div_cancel' _ h‚ÇÇ]

variable {Œπ A n} in
theorem UnitBoxPart_le_UnitBox {ŒΩ : Œπ ‚Üí ‚Ñ§} :
    UnitBoxPart Œπ n ŒΩ ‚â§ UnitBox Œπ A ‚Üî ŒΩ ‚àà AdmissibleIndex Œπ A n := by
  have h : 0 < (n:‚Ñù) := Nat.cast_pos.mpr n.pos
  simp_rw [BoxIntegral.Box.le_iff_bounds, UnitBox, UnitBoxPart, AdmissibleIndex, mem_piFinset,
    Finset.mem_Ico, Pi.le_def, ‚Üê forall_and, ‚Üê add_div, le_div_iff' h, div_le_iff' h,
    Int.lt_iff_add_one_le, ‚Üê Int.cast_le (Œ± := ‚Ñù), Int.cast_mul, Int.cast_add, Int.cast_one,
    Int.cast_neg, Int.cast_ofNat]

variable [DecidableEq (BoxIntegral.Box Œπ)]

def UnitBoxTaggedPrepartition : BoxIntegral.TaggedPrepartition (UnitBox Œπ A) where
  boxes := Finset.image (fun ŒΩ ‚Ü¶ UnitBoxPart Œπ n ŒΩ) (AdmissibleIndex Œπ A n)
  le_of_mem' _ hB := by
    obtain ‚ü®_, hŒΩ, rfl‚ü© := Finset.mem_image.mp hB
    exact UnitBoxPart_le_UnitBox.mpr hŒΩ
  pairwiseDisjoint := by
    intro _ hB _ hB'
    obtain ‚ü®_, _, rfl‚ü© := Finset.mem_image.mp hB
    obtain ‚ü®_, _, rfl‚ü© := Finset.mem_image.mp hB'
    rw [(UnitBoxPart_injective Œπ n).ne_iff]
    intro h
    exact (UnitBoxPart_disjoint Œπ n).mp h
  tag := by
    intro B
    by_cases hB : ‚àÉ ŒΩ ‚àà AdmissibleIndex Œπ A n, B = UnitBoxPart Œπ n ŒΩ
    ¬∑ exact UnitBoxTag Œπ n hB.choose
    ¬∑ exact 1
  tag_mem_Icc := by
    intro B
    split_ifs with h
    ¬∑ refine BoxIntegral.Box.coe_subset_Icc ?_
      rw [BoxIntegral.Box.mem_coe]
      have t2 := UnitBoxPart_le_UnitBox.mpr h.choose_spec.1
      refine t2 ?_
      exact UnitBoxTag_mem_unitBoxPart Œπ n (Exists.choose h)
    ¬∑ refine BoxIntegral.Box.coe_subset_Icc ?_
      rw [BoxIntegral.Box.mem_coe, UnitBox_mem]
      intro _
      simp
      refine ‚ü®?_, ?_‚ü©
      linarith
      exact A.pos

variable {Œπ A n} in
@[simp]
theorem mem_UnitBoxTaggedPrepartition_iff {B : BoxIntegral.Box Œπ} :
    B ‚àà UnitBoxTaggedPrepartition Œπ A n ‚Üî
      ‚àÉ ŒΩ ‚àà AdmissibleIndex Œπ A n, UnitBoxPart Œπ n ŒΩ = B := by simp [UnitBoxTaggedPrepartition]

theorem UnitBoxPart_index_mem {x : Œπ ‚Üí ‚Ñù} (hx : x ‚àà UnitBox Œπ A) :
    UnitBoxPart Œπ n (UnitBoxIndex Œπ n x) ‚àà UnitBoxTaggedPrepartition Œπ A n := by
  rw [mem_UnitBoxTaggedPrepartition_iff]
  refine ‚ü®UnitBoxIndex Œπ n x, ?_, rfl‚ü©
  rw [UnitBoxIndex_admissible_iff]
  exact hx

@[simp]
theorem UnitBoxTaggedPrepartition_tag_eq {ŒΩ : Œπ ‚Üí ‚Ñ§} (hŒΩ : ŒΩ ‚àà AdmissibleIndex Œπ A n) :
    (UnitBoxTaggedPrepartition Œπ A n).tag (UnitBoxPart Œπ n ŒΩ) = UnitBoxTag Œπ n ŒΩ := by
  dsimp only [UnitBoxTaggedPrepartition]
  have h : ‚àÉ ŒΩ' ‚àà AdmissibleIndex Œπ A n, UnitBoxPart Œπ n ŒΩ = UnitBoxPart Œπ n ŒΩ' := ‚ü®ŒΩ, hŒΩ, rfl‚ü©
  rw [dif_pos h, (UnitBoxTag_injective Œπ n).eq_iff, ‚Üê (UnitBoxPart_injective Œπ n).eq_iff]
  exact h.choose_spec.2.symm

theorem UnitBoxTaggedPrepartition_isHenstock :
    (UnitBoxTaggedPrepartition Œπ A n).IsHenstock := by
  intro _ hB
  obtain ‚ü®ŒΩ, hŒΩ, rfl‚ü© := mem_UnitBoxTaggedPrepartition_iff.mp hB
  rw [UnitBoxTaggedPrepartition_tag_eq Œπ A n hŒΩ]
  exact BoxIntegral.Box.coe_subset_Icc (UnitBoxTag_mem_unitBoxPart Œπ n ŒΩ)

theorem UnitBoxTaggedPrepartition_isPartition :
    (UnitBoxTaggedPrepartition Œπ A n).IsPartition := by
  intro x hx
  use UnitBoxPart Œπ n (UnitBoxIndex Œπ n x)
  refine ‚ü®?_, ?_‚ü©
  ¬∑ rw [BoxIntegral.TaggedPrepartition.mem_toPrepartition, mem_UnitBoxTaggedPrepartition_iff]
    exact ‚ü®UnitBoxIndex Œπ n x, UnitBoxIndex_admissible_iff.mpr hx, rfl‚ü©
  ¬∑ exact (UnitBoxPart_mem_iff_index_eq Œπ n).mpr rfl

theorem UnitBoxTaggedPrepartition_isSubordinate {r : ‚Ñù} (hr : 0 < r) (hn : 1 / r ‚â§ n) :
    (UnitBoxTaggedPrepartition Œπ A n).IsSubordinate (fun _ ‚Ü¶ ‚ü®r, hr‚ü©) := by
  intro _ hB
  obtain ‚ü®ŒΩ, hŒΩ, rfl‚ü© := mem_UnitBoxTaggedPrepartition_iff.mp hB
  dsimp
  have t1 : Metric.diam (BoxIntegral.Box.Icc (UnitBoxPart Œπ n ŒΩ)) ‚â§ r := by
    refine le_trans (UnitBoxPart_diam Œπ n ŒΩ) ?_
    rw [div_le_iff]
    rwa [div_le_iff hr, mul_comm] at hn
    exact Nat.cast_pos.mpr n.pos
  intro x hx
  rw [Metric.mem_closedBall, UnitBoxTaggedPrepartition_tag_eq Œπ A n hŒΩ]
  have t2 : UnitBoxTag Œπ n ŒΩ ‚àà (BoxIntegral.Box.Icc (UnitBoxPart Œπ n ŒΩ)) := by
    refine BoxIntegral.Box.coe_subset_Icc ?_
    exact UnitBoxTag_mem_unitBoxPart _ _ _
  have t3 := Metric.dist_le_diam_of_mem ?_ hx t2
  exact le_trans t3 t1
  refine IsCompact.isBounded ?_
  exact BoxIntegral.Box.isCompact_Icc (UnitBoxPart Œπ n ŒΩ)

variable (s : Set (Œπ ‚Üí ‚Ñù))

abbrev IntegralPoints (c : ‚Ñù) : Set (Œπ ‚Üí ‚Ñù) := c ‚Ä¢ s ‚à© span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ))

-- Only keep this version and just prove the equiv with the other one
abbrev IntegralPoints' (c : ‚Ñù) : Set (Œπ ‚Üí ‚Ñù) := s ‚à© c‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ))

variable (F : (Œπ ‚Üí ‚Ñù) ‚Üí ‚Ñù) (hF : Continuous F)

open scoped BigOperators

-- Define c before so that arguments are always in the same order
def CountingFunction (c : ‚Ñù) := Nat.card (IntegralPoints Œπ s c)

-- Probably inline that instead
abbrev SeriesFunction (c : ‚Ñù) := ‚àë' x : IntegralPoints Œπ s c, F x

theorem IntegralPoints_mem_iff {x : Œπ ‚Üí ‚Ñù} :
    x ‚àà IntegralPoints Œπ s n ‚Üî (n:‚Ñù)‚Åª¬π ‚Ä¢ x ‚àà IntegralPoints' Œπ s n := by
  simp only [Set.mem_inter_iff, SetLike.mem_coe, ne_eq, Nat.cast_eq_zero, PNat.ne_zero,
    not_false_eq_true, ‚Üê Set.mem_smul_set_iff_inv_smul_mem‚ÇÄ, smul_inv_smul‚ÇÄ]

def IntegralPointsEquiv : IntegralPoints Œπ s n ‚âÉ IntegralPoints' Œπ s n := by
  refine Equiv.ofBijective ?_ ‚ü®?_, ?_‚ü©
  ¬∑ rintro ‚ü®x, hx‚ü©
    exact ‚ü®(n:‚Ñù)‚Åª¬π ‚Ä¢ x, (IntegralPoints_mem_iff Œπ n s).mp hx‚ü©
  ¬∑ intro _ _ h
    have := congr_arg ((n:‚Ñù) ‚Ä¢ ¬∑) (Subtype.mk_eq_mk.mp h)
    simpa [smul_inv_smul‚ÇÄ, SetCoe.ext_iff, this]
  ¬∑ rintro ‚ü®y, hy‚ü©
    refine ‚ü®‚ü®((n:‚Ñù) ‚Ä¢ y), ?_‚ü©, ?_‚ü©
    ¬∑ simpa only [IntegralPoints_mem_iff, ne_eq, Nat.cast_eq_zero, PNat.ne_zero, not_false_eq_true,
      inv_smul_smul‚ÇÄ]
    ¬∑ simp only [ne_eq, Nat.cast_eq_zero, PNat.ne_zero, not_false_eq_true, inv_smul_smul‚ÇÄ]

theorem IntegralPointsEquiv_apply (x : IntegralPoints Œπ s n) :
    (IntegralPointsEquiv Œπ n s x : Œπ ‚Üí ‚Ñù) = (n:‚Ñù)‚Åª¬π ‚Ä¢ x := rfl

theorem IntegralPointsEquiv_symm_apply (x : IntegralPoints' Œπ s n) :
    ((IntegralPointsEquiv Œπ n s).symm x : Œπ ‚Üí ‚Ñù) = (n:‚Ñù) ‚Ä¢ x := by
  have := IntegralPointsEquiv_apply Œπ n s ((IntegralPointsEquiv Œπ n s).symm x)
  simp only [Equiv.apply_symm_apply] at this
  rw [this]
  simp

theorem UnitBoxTag_mem_smul_span (ŒΩ : Œπ ‚Üí ‚Ñ§) :
    UnitBoxTag Œπ n ŒΩ ‚àà (n:‚Ñù)‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ)) := by
  simp_rw [‚Üê SetLike.mem_coe, coe_pointwise_smul, Set.mem_smul_set, SetLike.mem_coe,
    Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, algebraMap_int_eq, Int.coe_castRingHom,
    Set.mem_range]
  refine ‚ü®?_, ?_‚ü©
  ¬∑ exact fun i ‚Ü¶ ŒΩ i + 1
  ¬∑ refine ‚ü®?_, ?_‚ü©
    ¬∑ intro i
      use ŒΩ i + 1
      zify
    ¬∑ ext i
      rw [Pi.smul_apply, smul_eq_mul, UnitBoxTag]
      ring

theorem UnitBoxTag_eq_of_mem_smul_span {x : Œπ ‚Üí ‚Ñù}
    (hx : x ‚àà (n:‚Ñù)‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ))) :
    UnitBoxTag Œπ n (UnitBoxIndex Œπ n x) = x := by
  simp_rw [‚Üê SetLike.mem_coe, coe_pointwise_smul, Set.mem_smul_set, SetLike.mem_coe,
    Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, algebraMap_int_eq, Int.coe_castRingHom,
    Set.mem_range] at hx
  obtain ‚ü®ŒΩ, hŒΩ, rfl‚ü© := hx
  ext i
  obtain ‚ü®y, hy‚ü© := hŒΩ i
  rw [UnitBoxTag, UnitBoxIndex, Pi.smul_apply, ‚Üê hy, smul_eq_mul, ‚Üê mul_assoc, mul_inv_cancel,
    one_mul, Int.cast_sub, Int.cast_one, sub_add_cancel]
  rw [Int.ceil_intCast]
  ring
  rw [Nat.cast_ne_zero]
  exact PNat.ne_zero n

theorem UnitBoxIndex_injective_of_mem {x y : Œπ ‚Üí ‚Ñù}
    (hx : x ‚àà (n:‚Ñù)‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ)))
    (hy : y ‚àà (n:‚Ñù)‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ)))
    (h : UnitBoxIndex Œπ n x = UnitBoxIndex Œπ n y) : x = y := by
  have := congr_arg (UnitBoxTag Œπ n ¬∑) h
  dsimp only at this
  rwa [UnitBoxTag_eq_of_mem_smul_span Œπ n hx, UnitBoxTag_eq_of_mem_smul_span Œπ n hy] at this

theorem UnitBoxTaggedPrepartition_tag_mem {x : Œπ ‚Üí ‚Ñù} (hs‚ÇÅ : s ‚â§ UnitBox Œπ A)
    (hx : x ‚àà IntegralPoints' Œπ s n) :
    (UnitBoxTaggedPrepartition Œπ A n).tag (UnitBoxPart Œπ n (UnitBoxIndex Œπ n x)) ‚àà s := by
  rw [UnitBoxTaggedPrepartition_tag_eq, UnitBoxTag_eq_of_mem_smul_span]
  exact hx.1
  exact hx.2
  rw [UnitBoxIndex_admissible_iff]
  exact hs‚ÇÅ hx.1

-- variable (hs‚ÇÅ : s ‚â§ UnitBox Œπ H)

-- theorem Index_admissible_of_mem0 {x : Œπ ‚Üí ‚Ñù} (hx : x ‚àà IntegralPoints' Œπ s n) :
--     UnitBoxIndex Œπ n x ‚àà AdmissibleIndex Œπ lw up n := by
--   rw [‚Üê @UnitBox_mem_iff_index]
--   refine hs‚ÇÅ (Set.mem_of_mem_inter_left hx)

theorem SeriesFunction_eq (hs‚ÇÅ : s ‚â§ UnitBox Œπ A) :
    ‚àë' x : IntegralPoints Œπ s n, F ((n:‚Ñù)‚Åª¬π ‚Ä¢ x) =
      Finset.sum (UnitBoxTaggedPrepartition Œπ A n).toPrepartition.boxes
        fun B ‚Ü¶ (Set.indicator s F ((UnitBoxTaggedPrepartition Œπ A n).tag B)) := by
  classical
  simp_rw [‚Üê Equiv.tsum_eq (IntegralPointsEquiv Œπ n s).symm, IntegralPointsEquiv_symm_apply]
  have : Fintype (IntegralPoints' Œπ s n) := by
    convert Fintype.ofEquiv (IntegralPoints Œπ s n) (IntegralPointsEquiv Œπ n s)
    rw [IntegralPoints]
    refine Set.Finite.fintype ?_
    refine Metric.finite_isBounded_inter_isClosed ?_ ?_
    refine Bornology.IsBounded.smul‚ÇÄ ?_ _
    have := UnitBox_isBounded Œπ A
    exact Bornology.IsBounded.subset this hs‚ÇÅ
    change IsClosed (span ‚Ñ§ (Set.range (Pi.basisFun ‚Ñù Œπ))).toAddSubgroup
    exact AddSubgroup.isClosed_of_discrete
  rw [tsum_fintype]
  rw [Finset.sum_indicator_eq_sum_filter]
  have : (n:‚Ñù) ‚â† 0 := by
    rw [Nat.cast_ne_zero]
    exact PNat.ne_zero n
  simp_rw [inv_smul_smul‚ÇÄ this]
  rw [Finset.sum_set_coe (IntegralPoints' Œπ s n)]
  refine Finset.sum_nbij ?_ ?_ ?_ ?_ ?_
  ¬∑ exact fun x ‚Ü¶ UnitBoxPart Œπ n (UnitBoxIndex Œπ n x)
  ¬∑ simp_rw [Set.mem_toFinset, Finset.mem_filter]
    intro x hx
    rw [BoxIntegral.Prepartition.mem_boxes, BoxIntegral.TaggedPrepartition.mem_toPrepartition]
    ¬∑ refine ‚ü®?_, ?_‚ü©
      ¬∑ refine UnitBoxPart_index_mem Œπ A n ?_
        exact hs‚ÇÅ hx.1
      ¬∑ exact UnitBoxTaggedPrepartition_tag_mem Œπ A n s hs‚ÇÅ hx
  ¬∑ simp_rw [Set.coe_toFinset]
    intro x hx y hy h
    rw [(UnitBoxPart_injective Œπ n).eq_iff] at h
    exact UnitBoxIndex_injective_of_mem Œπ n hx.2 hy.2 h
  ¬∑ intro x hx
    rw [Finset.coe_filter, Set.mem_setOf_eq, BoxIntegral.Prepartition.mem_boxes,
      BoxIntegral.TaggedPrepartition.mem_toPrepartition, mem_UnitBoxTaggedPrepartition_iff] at hx
    obtain ‚ü®‚ü®ŒΩ, hŒΩ, rfl‚ü©, h‚ü© := hx
    refine ‚ü®?_, ?_, ?_‚ü©
    ¬∑ exact UnitBoxTag Œπ n ŒΩ
    ¬∑ rw [Set.coe_toFinset, Set.mem_inter_iff]
      refine ‚ü®?_, ?_‚ü©
      ¬∑ rwa [UnitBoxTaggedPrepartition_tag_eq Œπ A n hŒΩ] at h
      ¬∑ rw [‚Üê coe_pointwise_smul]
        exact UnitBoxTag_mem_smul_span Œπ n ŒΩ
    ¬∑ simp
  ¬∑ intro x hx
    rw [Set.mem_toFinset] at hx
    rw [UnitBoxTaggedPrepartition_tag_eq, UnitBoxTag_eq_of_mem_smul_span]
    ¬∑ exact hx.2
    ¬∑ rw [UnitBoxIndex_admissible_iff]
      exact hs‚ÇÅ hx.1

theorem UnitBoxTaggedPrepartition_integralSum' (hs‚ÇÅ : s ‚â§ UnitBox Œπ A) :
    BoxIntegral.integralSum (Set.indicator s F)
      (BoxIntegral.BoxAdditiveMap.toSMul (Measure.toBoxAdditive volume))
        (UnitBoxTaggedPrepartition Œπ A n) = (
        ‚àë' x : IntegralPoints Œπ s n, F ((n:‚Ñù)‚Åª¬π ‚Ä¢ x)) / n ^ card Œπ := by
  unfold BoxIntegral.integralSum
  rw [SeriesFunction_eq Œπ A n s F hs‚ÇÅ, Finset.sum_div]
  refine Finset.sum_congr rfl ?_
  rintro _ hB
  rw [BoxIntegral.Prepartition.mem_boxes, BoxIntegral.TaggedPrepartition.mem_toPrepartition,
    mem_UnitBoxTaggedPrepartition_iff] at hB
  obtain ‚ü®_, _, rfl‚ü© := hB
  rw [BoxIntegral.BoxAdditiveMap.toSMul_apply, Measure.toBoxAdditive_apply, UnitBoxPart_volume,
    smul_eq_mul, mul_comm, mul_one_div]

theorem UnitBoxTaggedPrepartition_integralSum n (hs‚ÇÅ : s ‚â§ UnitBox Œπ A) :
    BoxIntegral.integralSum (Set.indicator s fun x ‚Ü¶ 1)
      (BoxIntegral.BoxAdditiveMap.toSMul (Measure.toBoxAdditive volume))
      (UnitBoxTaggedPrepartition Œπ A n) = (CountingFunction Œπ s n : ‚Ñù) / n ^ card Œπ := by
  convert UnitBoxTaggedPrepartition_integralSum' Œπ A n s (fun _ ‚Ü¶ (1:‚Ñù)) hs‚ÇÅ
  rw [tsum_const, nsmul_eq_mul, mul_one, Nat.cast_inj]
  rfl

variable (hs‚ÇÅ : Bornology.IsBounded s) (hs‚ÇÇ : MeasurableSet s)

theorem main' :
    Tendsto (fun n : ‚Ñï+ ‚Ü¶ (‚àë' x : IntegralPoints Œπ s n, F ((n:‚Ñù)‚Åª¬π ‚Ä¢ x)) / n ^ card Œπ)
      atTop (nhds (‚à´ x in s, F x)) := by
  obtain ‚ü®R, hR‚ÇÅ, hR‚ÇÇ‚ü© := Bornology.IsBounded.subset_ball_lt hs‚ÇÅ 0 0
  let C : ‚Ñï+ := ‚ü®Nat.ceil R, Nat.ceil_pos.mpr hR‚ÇÅ‚ü©
  have hs : s ‚â§ UnitBox Œπ C := by
    have := UnitBox_ball_le Œπ C
    refine le_trans ?_ this
    refine le_trans hR‚ÇÇ (Metric.ball_subset_ball ?_)
    exact Nat.le_ceil _
  have : ContinuousOn (Set.indicator s (fun x ‚Ü¶ F x)) (BoxIntegral.Box.Icc (UnitBox Œπ C)) := sorry
  have main := ContinuousOn.hasBoxIntegral (volume : Measure (Œπ ‚Üí ‚Ñù)) this
    BoxIntegral.IntegrationParams.Riemann
  rw [BoxIntegral.hasIntegral_iff] at main
  have : ‚à´ x in (UnitBox Œπ C), Set.indicator s F x = ‚à´ x in s, F x := by
    rw [MeasureTheory.integral_indicator hs‚ÇÇ]
    rw [Measure.restrict_restrict_of_subset hs]
  rw [this] at main
  rw [Metric.tendsto_atTop]
  intro eps h_eps
  specialize main (eps / 2) (half_pos h_eps)
  obtain ‚ü®r, hr‚ÇÅ, hr‚ÇÇ‚ü© := main
  specialize hr‚ÇÅ 0 rfl -- this say that ‚àÄ x, r x = r 0
  specialize hr‚ÇÇ 0
  let N : ‚Ñï+ := by
    refine ‚ü®?_, ?_‚ü©
    exact Nat.ceil (1 / (r 0 0 : ‚Ñù))
    rw [Nat.ceil_pos, one_div, inv_pos]
    exact (r 0 0).mem
  use N
  intro n hn

  have : ‚àÄ n, N ‚â§ n ‚Üí
      BoxIntegral.IntegrationParams.MemBaseSet BoxIntegral.IntegrationParams.Riemann
        (UnitBox Œπ C) 0 (r 0) (UnitBoxTaggedPrepartition Œπ C n) := by
    intro n hn
    refine ‚ü®?_, ?_, ?_, ?_‚ü©
    ¬∑ have : r 0 = fun _ ‚Ü¶ r 0 0 := Function.funext_iff.mpr hr‚ÇÅ
      rw [this]
      refine UnitBoxTaggedPrepartition_isSubordinate Œπ _ _ _ ?_
      exact le_trans (Nat.le_ceil _) (Nat.cast_le.mpr hn)
    ¬∑ intro h
      simp [BoxIntegral.IntegrationParams.Riemann] at h
      exact UnitBoxTaggedPrepartition_isHenstock Œπ _ _
    ¬∑ intro h
      simp [BoxIntegral.IntegrationParams.Riemann] at h
    ¬∑ intro h
      simp [BoxIntegral.IntegrationParams.Riemann] at h

  specialize hr‚ÇÇ _ (this n hn) (UnitBoxTaggedPrepartition_isPartition Œπ C n)
  rw [UnitBoxTaggedPrepartition_integralSum'] at hr‚ÇÇ
  refine lt_of_le_of_lt hr‚ÇÇ ?_
  exact half_lt_self_iff.mpr h_eps
  exact hs

theorem main :
    Tendsto (fun n : ‚Ñï+ ‚Ü¶ (CountingFunction Œπ s n : ‚Ñù) / n ^ card Œπ)
      atTop (nhds (volume s).toReal) := by
  convert main' Œπ s (fun _ ‚Ü¶ 1) hs‚ÇÅ hs‚ÇÇ
  ¬∑ rw [tsum_const, nsmul_eq_mul, mul_one, Nat.cast_inj]
    rfl
  ¬∑ rw [set_integral_const, smul_eq_mul, mul_one]

end pi

noncomputable section general

open MeasureTheory MeasureTheory.Measure Submodule Filter Fintype

open scoped Pointwise

variable {E Œπ : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] (b : Basis Œπ ‚Ñù E)

variable (s : Set E)

abbrev LatticePoints (c : ‚Ñù) : Set E := c ‚Ä¢ s ‚à© span ‚Ñ§ (Set.range b)

abbrev LatticePoints' (c : ‚Ñù) : Set E := s ‚à© c‚Åª¬π ‚Ä¢ span ‚Ñ§ (Set.range b)

def LatticeCountingFunction (c : ‚Ñù) := Nat.card (LatticePoints b s c)

variable [Fintype Œπ]

def EquivIntegralPoints {c : ‚Ñù} (hc : c ‚â† 0) : LatticePoints' b s c ‚âÉ IntegralPoints' Œπ (b.equivFun '' s) c := by
  refine Equiv.ofBijective ?_ ‚ü®?_, ?_‚ü©
  ¬∑ rintro ‚ü®x, hx‚ü©
    refine ‚ü®b.equivFun x, ?_, ?_‚ü©
    ¬∑ exact ‚ü®_, hx.1, rfl‚ü©
    ¬∑ -- rw [‚Üê coe_pointwise_smul]
      refine ‚ü®c ‚Ä¢ b.equivFun x, ?_, ?_‚ü©
      ¬∑ rw [SetLike.mem_coe]
        simp_rw [Basis.mem_span_iff_repr_mem, Basis.equivFun_apply,
          Pi.basisFun_repr, Set.mem_range, Pi.smul_apply, smul_eq_mul]
        intro i
        refine ‚ü®?_, ?_‚ü©

        sorry
      ¬∑ simp [inv_smul_smul‚ÇÄ hc]



theorem toto (c : ‚Ñù) : LatticeCountingFunction b s c = CountingFunction Œπ (b.equivFun '' s) c := by
  refine Nat.card_congr ?_
  refine Set.BijOn.equiv b.equivFun ?_
  refine (Equiv.image_eq_iff_bijOn b.equivFun.toEquiv).mp ?_
  ext
  rw [LinearEquiv.coe_toEquiv, Set.InjOn.image_inter ((Basis.equivFun b).injective.injOn  _)
    (Set.subset_univ _) (Set.subset_univ _), Set.mem_inter_iff, Set.mem_inter_iff]
  erw [‚Üê Submodule.map_coe (b.equivFun.restrictScalars ‚Ñ§)]
  simp_rw [image_smul_set, Submodule.map_span, LinearEquiv.restrictScalars_apply, ‚Üê Set.range_comp]
  congr!
  ext
  rw [Function.comp_apply, Basis.equivFun_apply, Basis.repr_self]
  rfl

variable [MeasurableSpace E] [BorelSpace E]

variable [DecidableEq Œπ] [DecidableEq (BoxIntegral.Box Œπ)]

theorem main2 (hs‚ÇÅ : Bornology.IsBounded s) (hs‚ÇÇ : MeasurableSet s) :
    Tendsto (fun n : ‚Ñï+ ‚Ü¶ (LatticeCountingFunction b s n : ‚Ñù) / n ^ card Œπ)
      atTop (nhds (volume (b.equivFun '' s)).toReal) := by
  haveI : FiniteDimensional ‚Ñù E := FiniteDimensional.of_fintype_basis b
  simp_rw [toto]
  convert main Œπ _ ?_ ?_
  ¬∑ rw [‚Üê NormedSpace.isVonNBounded_iff ‚Ñù] at hs‚ÇÅ ‚ä¢
    have := Bornology.IsVonNBounded.image (E := E) (F := Œπ ‚Üí ‚Ñù) (œÉ := RingHom.id ‚Ñù) hs‚ÇÅ
    erw [‚Üê LinearMap.coe_toContinuousLinearMap']
    exact this _
  ¬∑ rw [LinearEquiv.image_eq_preimage]
    have : Continuous b.equivFun.symm := by
      exact LinearMap.continuous_of_finiteDimensional _
    have : Measurable b.equivFun.symm := by
      exact Continuous.measurable this
    exact this hs‚ÇÇ

variable (b‚ÇÄ : Basis Œπ ‚Ñù (Œπ ‚Üí ‚Ñù)) (s‚ÇÄ : Set (Œπ ‚Üí ‚Ñù)) (hs‚ÇÄ‚ÇÅ : Bornology.IsBounded s‚ÇÄ)
  (hs‚ÇÄ‚ÇÇ : MeasurableSet s‚ÇÄ)

theorem main3 :
    Tendsto (fun n : ‚Ñï+ ‚Ü¶ (LatticeCountingFunction b‚ÇÄ s‚ÇÄ n : ‚Ñù) / n ^ card Œπ)
      atTop (nhds (|(LinearEquiv.det b‚ÇÄ.equivFun : ‚Ñù)| * (volume s‚ÇÄ).toReal)) := by
  convert main2 b‚ÇÄ s‚ÇÄ hs‚ÇÄ‚ÇÅ hs‚ÇÄ‚ÇÇ using 2
  rw [LinearEquiv.image_eq_preimage]
  rw [‚Üê MeasureTheory.Measure.map_apply‚ÇÄ]
  ¬∑ erw [Real.map_linearMap_volume_pi_eq_smul_volume_pi]
    ¬∑ rw [LinearEquiv.det_coe_symm, inv_inv]
      simp only [LinearEquiv.coe_det, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,
        smul_eq_mul, ENNReal.toReal_mul, abs_nonneg, ENNReal.toReal_ofReal]
    ¬∑ refine IsUnit.ne_zero ?_
      exact LinearEquiv.isUnit_det' _
  ¬∑ have : Continuous b‚ÇÄ.equivFun.symm := by
      exact LinearMap.continuous_of_finiteDimensional _
    exact Continuous.aemeasurable this
  ¬∑ exact MeasurableSet.nullMeasurableSet hs‚ÇÄ‚ÇÇ

end general
