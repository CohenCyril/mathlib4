/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, Emily Riehl
-/
import Mathlib.CategoryTheory.Adjunction.Basic
import Mathlib.CategoryTheory.Conj
import Mathlib.CategoryTheory.Category.Basic
import Mathlib.CategoryTheory.Functor.Basic
import Mathlib.CategoryTheory.Functor.Category
import Mathlib.CategoryTheory.Whiskering

import Mathlib.Tactic.ApplyFun

#align_import category_theory.adjunction.mates from "leanprover-community/mathlib"@"cea27692b3fdeb328a2ddba6aabf181754543184"

/-!
# Mate of natural transformations

This file establishes the bijection between the 2-cells

         L‚ÇÅ                  R‚ÇÅ
      C --‚Üí D             C ‚Üê-- D
    G ‚Üì  ‚Üó  ‚Üì H         G ‚Üì  ‚Üò  ‚Üì H
      E --‚Üí F             E ‚Üê-- F
         L‚ÇÇ                  R‚ÇÇ

where `L‚ÇÅ ‚ä£ R‚ÇÅ` and `L‚ÇÇ ‚ä£ R‚ÇÇ`. The corresponding natural transformations are called mates.

This bijection includes a number of interesting cases as specializations. For instance, in the
special case where `G,H` are identity functors then the bijection preserves and reflects
isomorphisms (i.e. we have bijections`(L‚ÇÇ ‚ü∂ L‚ÇÅ) ‚âÉ (R‚ÇÅ ‚ü∂ R‚ÇÇ)`, and if either side is an iso then the
other side is as well). This demonstrates that adjoints to a given functor are unique up to
isomorphism (since if `L‚ÇÅ ‚âÖ L‚ÇÇ` then we deduce `R‚ÇÅ ‚âÖ R‚ÇÇ`).

Another example arises from considering the square representing that a functor `H` preserves
products, in particular the morphism `HA ‚®Ø H- ‚ü∂ H(A ‚®Ø -)`. Then provided `(A ‚®Ø -)` and `HA ‚®Ø -`
have left adjoints (for instance if the relevant categories are cartesian closed), the transferred
natural transformation is the exponential comparison morphism: `H(A ^ -) ‚ü∂ HA ^ H-`.
Furthermore if `H` has a left adjoint `L`, this morphism is an isomorphism iff its mate
`L(HA ‚®Ø -) ‚ü∂ A ‚®Ø L-` is an isomorphism, see
https://ncatlab.org/nlab/show/Frobenius+reciprocity#InCategoryTheory.
This also relates to Grothendieck's yoga of six operations, though this is not spelled out in
mathlib: https://ncatlab.org/nlab/show/six+operations.
-/

universe v‚ÇÅ v‚ÇÇ v‚ÇÉ v‚ÇÑ v‚ÇÖ v‚ÇÜ v‚Çá v‚Çà v‚Çâ u‚ÇÅ u‚ÇÇ u‚ÇÉ u‚ÇÑ u‚ÇÖ u‚ÇÜ u‚Çá u‚Çà u‚Çâ
namespace CategoryTheory

open Category Functor Adjunction NatTrans

section Mates

variable {C : Type u‚ÇÅ} {D : Type u‚ÇÇ}{E : Type u‚ÇÉ} {F : Type u‚ÇÑ}
variable [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D][Category.{v‚ÇÉ} E] [Category.{v‚ÇÑ} F]
variable {G : C ‚•§ E} {H : D ‚•§ F} {L‚ÇÅ : C ‚•§ D} {R‚ÇÅ : D ‚•§ C} {L‚ÇÇ : E ‚•§ F} {R‚ÇÇ : F ‚•§ E}
variable (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ)

/-- Suppose we have a square of functors (where the top and
bottom are adjunctions `L‚ÇÅ ‚ä£ R‚ÇÅ` and `L‚ÇÇ ‚ä£ R‚ÇÇ` respectively).

      C ‚Üî D
    G ‚Üì   ‚Üì H
      E ‚Üî F

Then we have a bijection between natural transformations `G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H` and
`R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ`. This can be seen as a bijection of the 2-cells:

         L‚ÇÅ                  R‚ÇÅ
      C --‚Üí D             C ‚Üê-- D
    G ‚Üì  ‚Üó  ‚Üì H         G ‚Üì  ‚Üò  ‚Üì H
      E --‚Üí F             E ‚Üê-- F
         L‚ÇÇ                  R‚ÇÇ

Note that if one of the transformations is an iso, it does not imply the other is an iso.
-/

-- ER: The original definition of the mates equivalence.
def transferNatTrans : (G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) ‚âÉ (R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ) where
  toFun h :=
    { app := fun X => adj‚ÇÇ.unit.app _ ‚â´ R‚ÇÇ.map (h.app _ ‚â´ H.map (adj‚ÇÅ.counit.app _))
      naturality := fun X Y f => by
        dsimp
        rw [assoc, ‚Üê R‚ÇÇ.map_comp, assoc, ‚Üê H.map_comp, ‚Üê adj‚ÇÅ.counit_naturality, H.map_comp, ‚Üê
          Functor.comp_map L‚ÇÅ, ‚Üê h.naturality_assoc]
        simp }
  invFun h :=
    { app := fun X => L‚ÇÇ.map (G.map (adj‚ÇÅ.unit.app _) ‚â´ h.app _) ‚â´ adj‚ÇÇ.counit.app _
      naturality := fun X Y f => by
        dsimp
        rw [‚Üê L‚ÇÇ.map_comp_assoc, ‚Üê G.map_comp_assoc, ‚Üê adj‚ÇÅ.unit_naturality, G.map_comp_assoc, ‚Üê
          Functor.comp_map, h.naturality]
        simp }
  left_inv h := by
    ext X
    dsimp
    simp only [L‚ÇÇ.map_comp, assoc, adj‚ÇÇ.counit_naturality, adj‚ÇÇ.left_triangle_components_assoc, ‚Üê
      Functor.comp_map G L‚ÇÇ, h.naturality_assoc, Functor.comp_map L‚ÇÅ, ‚Üê H.map_comp,
      adj‚ÇÅ.left_triangle_components]
    dsimp
    simp only [id_comp, ‚Üê Functor.comp_map, ‚Üê Functor.comp_obj, NatTrans.naturality_assoc]
    simp only [Functor.comp_obj, Functor.comp_map, ‚Üê Functor.map_comp]
    have : Prefunctor.map L‚ÇÅ.toPrefunctor (NatTrans.app adj‚ÇÅ.unit X) ‚â´
        NatTrans.app adj‚ÇÅ.counit (Prefunctor.obj L‚ÇÅ.toPrefunctor X) = ùüô _ := by simp
    simp [this]
  -- See library note [dsimp, simp].
  right_inv h := by
    ext X
    dsimp
    simp [-Functor.comp_map, ‚Üê Functor.comp_map H, Functor.comp_map R‚ÇÅ, -NatTrans.naturality, ‚Üê
      h.naturality, -Functor.map_comp, ‚Üê Functor.map_comp_assoc G, R‚ÇÇ.map_comp]
#align category_theory.transfer_nat_trans CategoryTheory.transferNatTrans

/-- Corresponding natural transformations under the equivalence below are called mates.-/
@[simps]
def Mates :
    (G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) ‚âÉ (R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ) where
      toFun := fun Œ± ‚Ü¶
        whiskerLeft (R‚ÇÅ ‚ãô G) adj‚ÇÇ.unit ‚â´
        whiskerRight (whiskerLeft R‚ÇÅ Œ±) R‚ÇÇ ‚â´
        whiskerRight adj‚ÇÅ.counit (H ‚ãô R‚ÇÇ)
      invFun := fun Œ≤ ‚Ü¶
        whiskerRight adj‚ÇÅ.unit (G ‚ãô L‚ÇÇ) ‚â´
        whiskerRight (whiskerLeft L‚ÇÅ Œ≤) L‚ÇÇ ‚â´
        whiskerLeft (L‚ÇÅ ‚ãô H) adj‚ÇÇ.counit
      left_inv := by
        intro Œ±
        ext
        unfold whiskerRight whiskerLeft
        simp only [comp_obj, id_obj, Functor.comp_map, comp_app, map_comp, assoc, counit_naturality,
          counit_naturality_assoc, left_triangle_components_assoc]
        rw [‚Üê assoc, ‚Üê Functor.comp_map, Œ±.naturality, Functor.comp_map, assoc, ‚Üê H.map_comp,
          left_triangle_components, map_id]
        simp only [comp_obj, comp_id]
      right_inv := by
        intro Œ≤
        ext
        unfold whiskerLeft whiskerRight
        simp only [comp_obj, id_obj, Functor.comp_map, comp_app, map_comp, assoc,
          unit_naturality_assoc, right_triangle_components_assoc]
        rw [‚Üê assoc, ‚Üê Functor.comp_map, assoc, ‚Üê Œ≤.naturality, ‚Üê assoc, Functor.comp_map,
          ‚Üê G.map_comp, right_triangle_components, map_id, id_comp]
#align category_theory.mates CategoryTheory.Mates

-- ER: Note these definitions agree.
theorem RightMateEqualsTransferNatTrans
    (Œ± : G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) :
    Mates adj‚ÇÅ adj‚ÇÇ Œ± = (transferNatTrans adj‚ÇÅ adj‚ÇÇ) Œ± := by
  ext; unfold Mates transferNatTrans; simp

-- ER: Note these definitions agree.
theorem LeftMateEqualsTransferNatTrans.symm
    (Œ± : R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ) :
    (Mates adj‚ÇÅ adj‚ÇÇ).symm Œ± = (transferNatTrans adj‚ÇÅ adj‚ÇÇ).symm Œ± := by
  ext; unfold Mates transferNatTrans; simp

-- ER: Propose to cut and replace with the version below:
theorem transferNatTrans_counit (f : G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) (Y : D) :
    L‚ÇÇ.map ((transferNatTrans adj‚ÇÅ adj‚ÇÇ f).app _) ‚â´ adj‚ÇÇ.counit.app _ =
      f.app _ ‚â´ H.map (adj‚ÇÅ.counit.app Y) := by
  erw [Functor.map_comp]
  simp

/-- A component of a transposed version of the mates correspondence. -/
theorem Mates_counit (Œ± : G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) (d : D) :
    L‚ÇÇ.map ((Mates adj‚ÇÅ adj‚ÇÇ Œ±).app _) ‚â´ adj‚ÇÇ.counit.app _ =
      Œ±.app _ ‚â´ H.map (adj‚ÇÅ.counit.app d) := by
  erw [Functor.map_comp]; simp

-- ER: Propose to cut and replace with the version below:
theorem unit_transferNatTrans (f : G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) (X : C) :
    G.map (adj‚ÇÅ.unit.app X) ‚â´ (transferNatTrans adj‚ÇÅ adj‚ÇÇ f).app _ =
      adj‚ÇÇ.unit.app _ ‚â´ R‚ÇÇ.map (f.app _) := by
  dsimp [transferNatTrans]
  rw [‚Üê adj‚ÇÇ.unit_naturality_assoc, ‚Üê R‚ÇÇ.map_comp, ‚Üê Functor.comp_map G L‚ÇÇ, f.naturality_assoc,
    Functor.comp_map, ‚Üê H.map_comp]
  dsimp; simp
#align category_theory.unit_transfer_nat_trans CategoryTheory.unit_transferNatTrans

-- ER: I don't get why this is harder than the counit case.
/- A component of a transposed version of the mates correspondence. -/
theorem unit_Mates (Œ± : G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) (c : C) :
    G.map (adj‚ÇÅ.unit.app c) ‚â´ (Mates adj‚ÇÅ adj‚ÇÇ Œ±).app _ =
      adj‚ÇÇ.unit.app _ ‚â´ R‚ÇÇ.map (Œ±.app _) := by
  dsimp [Mates]
  rw [‚Üê adj‚ÇÇ.unit_naturality_assoc]
  slice_lhs 2 3 =>
    {
      rw [‚Üê R‚ÇÇ.map_comp, ‚Üê Functor.comp_map G L‚ÇÇ]
      rw [Œ±.naturality]
    }
  rw [R‚ÇÇ.map_comp]
  slice_lhs 3 4 =>
    {
      rw [‚Üê R‚ÇÇ.map_comp, Functor.comp_map L‚ÇÅ H]
      rw [‚Üê H.map_comp]
      rw [left_triangle_components]
    }
  simp only [comp_obj, map_id, comp_id]

-- See library note [dsimp, simp]
end Mates

section MatesVComp

variable {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ}
variable {D : Type u‚ÇÑ} {E : Type u‚ÇÖ} {F : Type u‚ÇÜ}
variable [Category.{v‚ÇÅ} A] [Category.{v‚ÇÇ} B][Category.{v‚ÇÉ} C]
variable [Category.{v‚ÇÑ} D] [Category.{v‚ÇÖ} E][Category.{v‚ÇÜ} F]
variable {G‚ÇÅ : A ‚•§ C}{G‚ÇÇ : C ‚•§ E}{H‚ÇÅ : B ‚•§ D}{H‚ÇÇ : D ‚•§ F}
variable {L‚ÇÅ : A ‚•§ B}{R‚ÇÅ : B ‚•§ A} {L‚ÇÇ : C ‚•§ D}{R‚ÇÇ : D ‚•§ C}
variable {L‚ÇÉ : E ‚•§ F}{R‚ÇÉ : F ‚•§ E}
variable (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (adj‚ÇÉ : L‚ÇÉ ‚ä£ R‚ÇÉ)

/-- Squares between left adjoints can be composed "vertically" by pasting. -/
def LeftAdjointSquare.vcomp :
    (G‚ÇÅ ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H‚ÇÅ) ‚Üí (G‚ÇÇ ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÇ ‚ãô H‚ÇÇ) ‚Üí ((G‚ÇÅ ‚ãô G‚ÇÇ) ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÅ ‚ãô (H‚ÇÅ ‚ãô H‚ÇÇ)) :=
  fun Œ± Œ≤ ‚Ü¶ (whiskerLeft G‚ÇÅ Œ≤) ‚â´ (whiskerRight Œ± H‚ÇÇ)
#align category_theory.leftadjointsquare_vcomp CategoryTheory.LeftAdjointSquare.vcomp

/-- Squares between right adjoints can be composed "vertically" by pasting. -/
def RightAdjointSquare.vcomp :
    (R‚ÇÅ ‚ãô G‚ÇÅ ‚ü∂ H‚ÇÅ ‚ãô R‚ÇÇ) ‚Üí (R‚ÇÇ ‚ãô G‚ÇÇ ‚ü∂ H‚ÇÇ ‚ãô R‚ÇÉ) ‚Üí (R‚ÇÅ ‚ãô (G‚ÇÅ ‚ãô G‚ÇÇ) ‚ü∂ (H‚ÇÅ ‚ãô H‚ÇÇ) ‚ãô R‚ÇÉ) :=
  fun Œ± Œ≤ ‚Ü¶ (whiskerRight Œ± G‚ÇÇ) ‚â´ (whiskerLeft H‚ÇÅ Œ≤)
#align category_theory.rightadjointsquare_vcomp CategoryTheory.RightAdjointSquare.vcomp

/-- The mates equivalence commutes with vertical composition. -/
theorem Mates_vcomp
    (Œ± : G‚ÇÅ ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H‚ÇÅ) (Œ≤ : G‚ÇÇ ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÇ ‚ãô H‚ÇÇ) :
    (Mates (G := G‚ÇÅ ‚ãô G‚ÇÇ) (H := H‚ÇÅ ‚ãô H‚ÇÇ) adj‚ÇÅ adj‚ÇÉ) (LeftAdjointSquare.vcomp Œ± Œ≤) =
      RightAdjointSquare.vcomp (Mates adj‚ÇÅ adj‚ÇÇ Œ±) (Mates adj‚ÇÇ adj‚ÇÉ Œ≤) := by
  unfold LeftAdjointSquare.vcomp RightAdjointSquare.vcomp Mates
  ext b
  simp only [comp_obj, Equiv.coe_fn_mk, whiskerLeft_comp, whiskerLeft_twice, whiskerRight_comp,
    assoc, comp_app, whiskerLeft_app, whiskerRight_app, id_obj, Functor.comp_map,
    whiskerRight_twice]
  slice_rhs 1 4 =>
    {
      rw [‚Üê assoc, ‚Üê assoc, ‚Üê unit_naturality (adj‚ÇÉ)]
    }
  rw [L‚ÇÉ.map_comp, R‚ÇÉ.map_comp]
  slice_rhs 2 4 =>
    {
      rw [‚Üê R‚ÇÉ.map_comp, ‚Üê R‚ÇÉ.map_comp, ‚Üê assoc, ‚Üê L‚ÇÉ.map_comp, ‚Üê G‚ÇÇ.map_comp, ‚Üê G‚ÇÇ.map_comp]
      rw [‚Üê Functor.comp_map G‚ÇÇ L‚ÇÉ, Œ≤.naturality]
    }
  rw [(L‚ÇÇ ‚ãô H‚ÇÇ).map_comp, R‚ÇÉ.map_comp, R‚ÇÉ.map_comp]
  slice_rhs 4 5 =>
    {
      rw [‚Üê R‚ÇÉ.map_comp, Functor.comp_map L‚ÇÇ _, ‚Üê Functor.comp_map _ L‚ÇÇ, ‚Üê H‚ÇÇ.map_comp]
      rw [adj‚ÇÇ.counit.naturality]
    }
  simp only [comp_obj, Functor.comp_map, map_comp, id_obj, Functor.id_map, assoc]
  slice_rhs 4 5 =>
    {
      rw [‚Üê R‚ÇÉ.map_comp, ‚Üê H‚ÇÇ.map_comp, ‚Üê Functor.comp_map _ L‚ÇÇ, adj‚ÇÇ.counit.naturality]
    }
  simp only [comp_obj, id_obj, Functor.id_map, map_comp, assoc]
  slice_rhs 3 4 =>
    {
      rw [‚Üê R‚ÇÉ.map_comp, ‚Üê H‚ÇÇ.map_comp, left_triangle_components]
    }
  simp only [map_id, id_comp]

end MatesVComp

section MatesHComp

variable {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ} {D : Type u‚ÇÑ} {E : Type u‚ÇÖ} {F : Type u‚ÇÜ}
variable [Category.{v‚ÇÅ} A] [Category.{v‚ÇÇ} B][Category.{v‚ÇÉ} C]
variable [Category.{v‚ÇÑ} D] [Category.{v‚ÇÖ} E][Category.{v‚ÇÜ} F]
variable {G : A ‚•§ D}{H : B ‚•§ E}{K : C ‚•§ F}
variable {L‚ÇÅ : A ‚•§ B}{R‚ÇÅ : B ‚•§ A} {L‚ÇÇ : D ‚•§ E}{R‚ÇÇ : E ‚•§ D}
variable {L‚ÇÉ : B ‚•§ C}{R‚ÇÉ : C ‚•§ B} {L‚ÇÑ : E ‚•§ F}{R‚ÇÑ : F ‚•§ E}
variable (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ)
variable (adj‚ÇÉ : L‚ÇÉ ‚ä£ R‚ÇÉ) (adj‚ÇÑ : L‚ÇÑ ‚ä£ R‚ÇÑ)

/-- Squares between left adjoints can be composed "horizontally" by pasting. -/
def LeftAdjointSquare.hcomp :
    (G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) ‚Üí (H ‚ãô L‚ÇÑ ‚ü∂ L‚ÇÉ ‚ãô K) ‚Üí (G ‚ãô (L‚ÇÇ ‚ãô L‚ÇÑ) ‚ü∂ (L‚ÇÅ ‚ãô L‚ÇÉ) ‚ãô K) := fun Œ± Œ≤ ‚Ü¶
  (whiskerRight Œ± L‚ÇÑ) ‚â´ (whiskerLeft L‚ÇÅ Œ≤)

/-- Squares between right adjoints can be composed "horizontally" by pasting. -/
def RightAdjointSquare.hcomp :
    (R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ) ‚Üí (R‚ÇÉ ‚ãô H ‚ü∂ K ‚ãô R‚ÇÑ) ‚Üí ((R‚ÇÉ ‚ãô R‚ÇÅ) ‚ãô G ‚ü∂ K ‚ãô (R‚ÇÑ ‚ãô R‚ÇÇ)) := fun Œ± Œ≤ ‚Ü¶
  (whiskerLeft R‚ÇÉ Œ±) ‚â´ (whiskerRight Œ≤ R‚ÇÇ)

/-- The mates equivalence commutes with horizontal composition of squares. -/
theorem Mates_hcomp
    (Œ± : G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) (Œ≤ : H ‚ãô L‚ÇÑ ‚ü∂ L‚ÇÉ ‚ãô K) :
    (Mates (adj‚ÇÅ.comp adj‚ÇÉ) (adj‚ÇÇ.comp adj‚ÇÑ)) (LeftAdjointSquare.hcomp Œ± Œ≤) =
      RightAdjointSquare.hcomp (Mates adj‚ÇÅ adj‚ÇÇ Œ±) (Mates adj‚ÇÉ adj‚ÇÑ Œ≤) := by
  unfold LeftAdjointSquare.hcomp RightAdjointSquare.hcomp Mates Adjunction.comp
  ext c
  simp only [comp_obj, whiskerLeft_comp, whiskerLeft_twice, whiskerRight_comp, assoc,
    Equiv.coe_fn_mk, comp_app, whiskerLeft_app, whiskerRight_app, id_obj, associator_inv_app,
    Functor.comp_map, associator_hom_app, map_id, id_comp, whiskerRight_twice]
  slice_rhs 2 4 =>
    {
      rw [‚Üê R‚ÇÇ.map_comp, ‚Üê R‚ÇÇ.map_comp, ‚Üê assoc, ‚Üê unit_naturality (adj‚ÇÑ)]
    }
  rw [R‚ÇÇ.map_comp, L‚ÇÑ.map_comp, R‚ÇÑ.map_comp, R‚ÇÇ.map_comp]
  slice_rhs 4 5 =>
    {
      rw [‚Üê R‚ÇÇ.map_comp, ‚Üê R‚ÇÑ.map_comp, ‚Üê Functor.comp_map _ L‚ÇÑ , Œ≤.naturality]
    }
  simp only [comp_obj, Functor.comp_map, map_comp, assoc]

end MatesHComp

section MatesSquareComp

variable {A : Type u‚ÇÅ} {B : Type u‚ÇÇ} {C : Type u‚ÇÉ}
variable {D : Type u‚ÇÑ} {E : Type u‚ÇÖ} {F : Type u‚ÇÜ}
variable {X : Type u‚Çá} {Y : Type u‚Çà} {Z : Type u‚Çâ}
variable [Category.{v‚ÇÅ} A] [Category.{v‚ÇÇ} B][Category.{v‚ÇÉ} C]
variable [Category.{v‚ÇÑ} D] [Category.{v‚ÇÖ} E][Category.{v‚ÇÜ} F]
variable [Category.{v‚Çá} X] [Category.{v‚Çà} Y][Category.{v‚Çâ} Z]
variable {G‚ÇÅ : A ‚•§ D} {H‚ÇÅ : B ‚•§ E} {K‚ÇÅ : C ‚•§ F} {G‚ÇÇ : D ‚•§ X} {H‚ÇÇ : E ‚•§ Y} {K‚ÇÇ : F ‚•§ Z}
variable {L‚ÇÅ : A ‚•§ B} {R‚ÇÅ : B ‚•§ A} {L‚ÇÇ : B ‚•§ C} {R‚ÇÇ : C ‚•§ B} {L‚ÇÉ : D ‚•§ E} {R‚ÇÉ : E ‚•§ D}
variable {L‚ÇÑ : E ‚•§ F} {R‚ÇÑ : F ‚•§ E} {L‚ÇÖ : X ‚•§ Y} {R‚ÇÖ : Y ‚•§ X} {L‚ÇÜ : Y ‚•§ Z} {R‚ÇÜ : Z ‚•§ Y}
variable (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (adj‚ÇÉ : L‚ÇÉ ‚ä£ R‚ÇÉ)
variable (adj‚ÇÑ : L‚ÇÑ ‚ä£ R‚ÇÑ) (adj‚ÇÖ : L‚ÇÖ ‚ä£ R‚ÇÖ) (adj‚ÇÜ : L‚ÇÜ ‚ä£ R‚ÇÜ)

/-- Squares of squares between left adjoints can be composed by iterating vertical and horizontal composition.-/
def LeftAdjointSquare.comp
    (Œ± : G‚ÇÅ ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÅ ‚ãô H‚ÇÅ) (Œ≤ : H‚ÇÅ ‚ãô L‚ÇÑ ‚ü∂ L‚ÇÇ ‚ãô K‚ÇÅ)
    (Œ≥ : G‚ÇÇ ‚ãô L‚ÇÖ ‚ü∂ L‚ÇÉ ‚ãô H‚ÇÇ) (Œ¥ : H‚ÇÇ ‚ãô L‚ÇÜ ‚ü∂ L‚ÇÑ ‚ãô K‚ÇÇ) :
    ((G‚ÇÅ ‚ãô G‚ÇÇ) ‚ãô (L‚ÇÖ ‚ãô L‚ÇÜ)) ‚ü∂ ((L‚ÇÅ ‚ãô L‚ÇÇ) ‚ãô (K‚ÇÅ ‚ãô K‚ÇÇ)) :=
  LeftAdjointSquare.vcomp (LeftAdjointSquare.hcomp Œ± Œ≤) (LeftAdjointSquare.hcomp Œ≥ Œ¥)
#align category_theory.leftadjointsquare_comp CategoryTheory.LeftAdjointSquare.comp

theorem LeftAdjointSquare.comp_vhcomp
    (Œ± : G‚ÇÅ ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÅ ‚ãô H‚ÇÅ) (Œ≤ : H‚ÇÅ ‚ãô L‚ÇÑ ‚ü∂ L‚ÇÇ ‚ãô K‚ÇÅ)
    (Œ≥ : G‚ÇÇ ‚ãô L‚ÇÖ ‚ü∂ L‚ÇÉ ‚ãô H‚ÇÇ) (Œ¥ : H‚ÇÇ ‚ãô L‚ÇÜ ‚ü∂ L‚ÇÑ ‚ãô K‚ÇÇ) :
    LeftAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥ =
      LeftAdjointSquare.vcomp (LeftAdjointSquare.hcomp Œ± Œ≤) (LeftAdjointSquare.hcomp Œ≥ Œ¥) := rfl

/-- Horizontal and vertical composition of squares commutes.-/
theorem LeftAdjointSquare.comp_hvcomp
    (Œ± : G‚ÇÅ ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÅ ‚ãô H‚ÇÅ) (Œ≤ : H‚ÇÅ ‚ãô L‚ÇÑ ‚ü∂ L‚ÇÇ ‚ãô K‚ÇÅ)
    (Œ≥ : G‚ÇÇ ‚ãô L‚ÇÖ ‚ü∂ L‚ÇÉ ‚ãô H‚ÇÇ) (Œ¥ : H‚ÇÇ ‚ãô L‚ÇÜ ‚ü∂ L‚ÇÑ ‚ãô K‚ÇÇ) :
    LeftAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥ =
      LeftAdjointSquare.hcomp (LeftAdjointSquare.vcomp Œ± Œ≥) (LeftAdjointSquare.vcomp Œ≤ Œ¥) := by
  unfold LeftAdjointSquare.comp LeftAdjointSquare.hcomp LeftAdjointSquare.vcomp
  unfold whiskerLeft whiskerRight
  ext a
  simp only [comp_obj, comp_app, map_comp, assoc]
  slice_rhs 2 3 =>
    {
      rw [‚Üê Functor.comp_map _ L‚ÇÜ, Œ¥.naturality]
    }
  simp only [comp_obj, Functor.comp_map, assoc]

/-- Squares of squares between right adjoints can be composed by iterating vertical and horizontal composition.-/
def RightAdjointSquare.comp
    (Œ± : R‚ÇÅ ‚ãô G‚ÇÅ ‚ü∂ H‚ÇÅ ‚ãô R‚ÇÉ) (Œ≤ : R‚ÇÇ ‚ãô H‚ÇÅ ‚ü∂ K‚ÇÅ ‚ãô R‚ÇÑ)
    (Œ≥ : R‚ÇÉ ‚ãô G‚ÇÇ ‚ü∂ H‚ÇÇ ‚ãô R‚ÇÖ) (Œ¥ : R‚ÇÑ ‚ãô H‚ÇÇ ‚ü∂ K‚ÇÇ ‚ãô R‚ÇÜ) :
    ((R‚ÇÇ ‚ãô R‚ÇÅ) ‚ãô (G‚ÇÅ ‚ãô G‚ÇÇ) ‚ü∂ (K‚ÇÅ ‚ãô K‚ÇÇ) ‚ãô (R‚ÇÜ ‚ãô R‚ÇÖ)) :=
  RightAdjointSquare.vcomp (RightAdjointSquare.hcomp Œ± Œ≤) (RightAdjointSquare.hcomp Œ≥ Œ¥)
#align category_theory.rightadjointsquare_comp CategoryTheory.RightAdjointSquare.comp

theorem RightAdjointSquare.comp_vhcomp
    (Œ± : R‚ÇÅ ‚ãô G‚ÇÅ ‚ü∂ H‚ÇÅ ‚ãô R‚ÇÉ) (Œ≤ : R‚ÇÇ ‚ãô H‚ÇÅ ‚ü∂ K‚ÇÅ ‚ãô R‚ÇÑ)
    (Œ≥ : R‚ÇÉ ‚ãô G‚ÇÇ ‚ü∂ H‚ÇÇ ‚ãô R‚ÇÖ) (Œ¥ : R‚ÇÑ ‚ãô H‚ÇÇ ‚ü∂ K‚ÇÇ ‚ãô R‚ÇÜ) :
    RightAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥ =
    RightAdjointSquare.vcomp (RightAdjointSquare.hcomp Œ± Œ≤) (RightAdjointSquare.hcomp Œ≥ Œ¥) := rfl

/-- Horizontal and vertical composition of squares commutes.-/
theorem RightAdjointSquare.comp_hvcomp
    (Œ± : R‚ÇÅ ‚ãô G‚ÇÅ ‚ü∂ H‚ÇÅ ‚ãô R‚ÇÉ) (Œ≤ : R‚ÇÇ ‚ãô H‚ÇÅ ‚ü∂ K‚ÇÅ ‚ãô R‚ÇÑ)
    (Œ≥ : R‚ÇÉ ‚ãô G‚ÇÇ ‚ü∂ H‚ÇÇ ‚ãô R‚ÇÖ) (Œ¥ : R‚ÇÑ ‚ãô H‚ÇÇ ‚ü∂ K‚ÇÇ ‚ãô R‚ÇÜ) :
    RightAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥ =
    RightAdjointSquare.hcomp (RightAdjointSquare.vcomp Œ± Œ≥) (RightAdjointSquare.vcomp Œ≤ Œ¥) := by
  unfold RightAdjointSquare.comp RightAdjointSquare.hcomp RightAdjointSquare.vcomp
  unfold whiskerLeft whiskerRight
  ext c
  simp only [comp_obj, comp_app, map_comp, assoc]
  slice_rhs 2 3 =>
    {
      rw [‚Üê Functor.comp_map _ R‚ÇÖ, ‚Üê Œ≥.naturality]
    }
  simp only [comp_obj, Functor.comp_map, assoc]

/-- The mates equivalence commutes with composition of squares of squares. These results form the basis for an isomorphism of double categories to be proven later.
-/
theorem Mates_square
    (Œ± : G‚ÇÅ ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÅ ‚ãô H‚ÇÅ) (Œ≤ : H‚ÇÅ ‚ãô L‚ÇÑ ‚ü∂ L‚ÇÇ ‚ãô K‚ÇÅ)
    (Œ≥ : G‚ÇÇ ‚ãô L‚ÇÖ ‚ü∂ L‚ÇÉ ‚ãô H‚ÇÇ) (Œ¥ : H‚ÇÇ ‚ãô L‚ÇÜ ‚ü∂ L‚ÇÑ ‚ãô K‚ÇÇ) :
    (Mates (G := G‚ÇÅ ‚ãô G‚ÇÇ) (H := K‚ÇÅ ‚ãô K‚ÇÇ) (adj‚ÇÅ.comp adj‚ÇÇ) (adj‚ÇÖ.comp adj‚ÇÜ))
        (LeftAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥) =
      RightAdjointSquare.comp
        (Mates adj‚ÇÅ adj‚ÇÉ Œ±) (Mates adj‚ÇÇ adj‚ÇÑ Œ≤) (Mates adj‚ÇÉ adj‚ÇÖ Œ≥) (Mates adj‚ÇÑ adj‚ÇÜ Œ¥) := by
  have vcomp :=
    Mates_vcomp (adj‚ÇÅ.comp adj‚ÇÇ) (adj‚ÇÉ.comp adj‚ÇÑ) (adj‚ÇÖ.comp adj‚ÇÜ)
      (LeftAdjointSquare.hcomp Œ± Œ≤) (LeftAdjointSquare.hcomp Œ≥ Œ¥)
  have hcomp1 := Mates_hcomp adj‚ÇÅ adj‚ÇÉ adj‚ÇÇ adj‚ÇÑ Œ± Œ≤
  have hcomp2 := Mates_hcomp adj‚ÇÉ adj‚ÇÖ adj‚ÇÑ adj‚ÇÜ Œ≥ Œ¥
  rw [hcomp1, hcomp2] at vcomp
  exact vcomp

end MatesSquareComp

section Conjugates

variable {C : Type u‚ÇÅ} {D : Type u‚ÇÇ}
variable [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D]
variable {L‚ÇÅ L‚ÇÇ L‚ÇÉ : C ‚•§ D} {R‚ÇÅ R‚ÇÇ R‚ÇÉ : D ‚•§ C}
variable (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (adj‚ÇÉ : L‚ÇÉ ‚ä£ R‚ÇÉ)

/-- Given two adjunctions `L‚ÇÅ ‚ä£ R‚ÇÅ` and `L‚ÇÇ ‚ä£ R‚ÇÇ` both between categories `C`, `D`, there is a
bijection between natural transformations `L‚ÇÇ ‚ü∂ L‚ÇÅ` and natural transformations `R‚ÇÅ ‚ü∂ R‚ÇÇ`. This is defined as a special case of `Mates`, where the two "vertical" functors are identity, modulo composition with the unitors.
TODO: Generalise to when the two vertical functors are equivalences rather than being exactly `ùü≠`.

Furthermore, this bijection preserves (and reflects) isomorphisms, i.e. a transformation is an iso
iff its image under the bijection is an iso, see eg `CategoryTheory.transferNatTransSelf_iso`.
This is in contrast to the general case `transferNatTrans` which
 does not in general have this property.-/

/-- Mates between parallel adjunctions are called conjugates. -/
def Conjugates : (L‚ÇÇ ‚ü∂ L‚ÇÅ) ‚âÉ (R‚ÇÅ ‚ü∂ R‚ÇÇ) :=
  calc
    (L‚ÇÇ ‚ü∂ L‚ÇÅ) ‚âÉ _ := (Iso.homCongr L‚ÇÇ.leftUnitor L‚ÇÅ.rightUnitor).symm
    _ ‚âÉ _ := Mates adj‚ÇÅ adj‚ÇÇ
    _ ‚âÉ (R‚ÇÅ ‚ü∂ R‚ÇÇ) := R‚ÇÅ.rightUnitor.homCongr R‚ÇÇ.leftUnitor

/-- A component of a transposed form of the conjugation definition. -/
theorem Conjugates_counit (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) (d : D) :
    L‚ÇÇ.map ((Conjugates adj‚ÇÅ adj‚ÇÇ Œ±).app _) ‚â´ adj‚ÇÇ.counit.app d =
      Œ±.app _ ‚â´ adj‚ÇÅ.counit.app d := by
  dsimp [Conjugates]
  rw [id_comp, comp_id]
  have := Mates_counit adj‚ÇÅ adj‚ÇÇ (L‚ÇÇ.leftUnitor.hom ‚â´ Œ± ‚â´ L‚ÇÅ.rightUnitor.inv) d
  dsimp at this
  rw [this]
  simp only [comp_id, id_comp]

/-- A component of a transposed form of the conjugation definition. -/
theorem unit_Conjugates (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) (c : C) :
    adj‚ÇÅ.unit.app _ ‚â´ (Conjugates adj‚ÇÅ adj‚ÇÇ Œ±).app _ =
      adj‚ÇÇ.unit.app c ‚â´ R‚ÇÇ.map (Œ±.app _) := by
  dsimp [Conjugates]
  rw [id_comp, comp_id]
  have := unit_Mates adj‚ÇÅ adj‚ÇÇ (L‚ÇÇ.leftUnitor.hom ‚â´ Œ± ‚â´ L‚ÇÅ.rightUnitor.inv) c
  dsimp at this
  rw [this]
  simp

@[simp]
theorem Conjugates_id : Conjugates adj‚ÇÅ adj‚ÇÅ (ùüô _) = ùüô _ := by
  ext
  dsimp [Conjugates, Mates]
  simp only [comp_id, map_id, id_comp, right_triangle_components]

@[simp]
theorem Conjugates_symm_id : (Conjugates adj‚ÇÅ adj‚ÇÅ).symm (ùüô _) = ùüô _ := by
  rw [Equiv.symm_apply_eq]
  simp only [Conjugates_id]
#align category_theory.conjugates_symm_id CategoryTheory.Conjugates_symm_id

theorem Conjugates_adjunction_id {L R : C ‚•§ C} (adj : L ‚ä£ R) (Œ± : ùü≠ C ‚ü∂ L) (c : C) :
    (Conjugates adj Adjunction.id Œ±).app c = Œ±.app (R.obj c) ‚â´ adj.counit.app c := by
  dsimp [Conjugates, Mates, Adjunction.id]
  simp only [comp_id, id_comp]

theorem Conjugates_adjunction_id_symm {L R : C ‚•§ C} (adj : L ‚ä£ R) (Œ± : R ‚ü∂ ùü≠ C) (c : C) :
    ((Conjugates adj Adjunction.id).symm Œ±).app c = adj.unit.app c ‚â´ Œ±.app (L.obj c) := by
  dsimp [Conjugates, Mates, Adjunction.id]
  simp only [comp_id, id_comp]
end Conjugates


section ConjugateComposition
variable {C : Type u‚ÇÅ} {D : Type u‚ÇÇ}
variable [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D]
variable {L‚ÇÅ L‚ÇÇ L‚ÇÉ : C ‚•§ D} {R‚ÇÅ R‚ÇÇ R‚ÇÉ : D ‚•§ C}
variable (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (adj‚ÇÉ : L‚ÇÉ ‚ä£ R‚ÇÉ)

theorem Conjugates_comp (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) (Œ≤ : L‚ÇÉ ‚ü∂ L‚ÇÇ) :
    Conjugates adj‚ÇÅ adj‚ÇÇ Œ± ‚â´ Conjugates adj‚ÇÇ adj‚ÇÉ Œ≤ =
      Conjugates adj‚ÇÅ adj‚ÇÉ (Œ≤ ‚â´ Œ±) := by
  ext d
  dsimp [Conjugates, Mates]
  have vcomp := Mates_vcomp adj‚ÇÅ adj‚ÇÇ adj‚ÇÉ
    (L‚ÇÇ.leftUnitor.hom ‚â´ Œ± ‚â´ L‚ÇÅ.rightUnitor.inv)
    (L‚ÇÉ.leftUnitor.hom ‚â´ Œ≤ ‚â´ L‚ÇÇ.rightUnitor.inv)
  have vcompd := congr_app vcomp d
  dsimp [Mates, LeftAdjointSquare.vcomp, RightAdjointSquare.vcomp] at vcompd
  simp at vcompd
  simp only [comp_id, id_comp, assoc, map_comp]
  rw [vcompd]

-- ER: Warning: swapped order of the arguments.
theorem Conjugates_symm_comp (Œ± : R‚ÇÅ ‚ü∂ R‚ÇÇ) (Œ≤ : R‚ÇÇ ‚ü∂ R‚ÇÉ) :
    (Conjugates adj‚ÇÇ adj‚ÇÉ).symm Œ≤ ‚â´ (Conjugates adj‚ÇÅ adj‚ÇÇ).symm Œ± =
      (Conjugates adj‚ÇÅ adj‚ÇÉ).symm (Œ± ‚â´ Œ≤) := by
  rw [Equiv.eq_symm_apply, ‚Üê Conjugates_comp _ adj‚ÇÇ]
  simp only [Equiv.apply_symm_apply]

theorem Conjugates_comm {Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ} {Œ≤ : L‚ÇÅ ‚ü∂ L‚ÇÇ} (Œ≤Œ± : Œ≤ ‚â´ Œ± = ùüô _) :
    Conjugates adj‚ÇÅ adj‚ÇÇ Œ± ‚â´ Conjugates adj‚ÇÇ adj‚ÇÅ Œ≤ = ùüô _ := by
  rw [Conjugates_comp, Œ≤Œ±, Conjugates_id]

theorem Conjugates_symm_comm {Œ± : R‚ÇÅ ‚ü∂ R‚ÇÇ}{Œ≤ : R‚ÇÇ ‚ü∂ R‚ÇÅ} (Œ±Œ≤ : Œ± ‚â´ Œ≤ = ùüô _) :
    (Conjugates adj‚ÇÇ adj‚ÇÅ).symm Œ≤ ‚â´ (Conjugates adj‚ÇÅ adj‚ÇÇ).symm Œ± = ùüô _ := by
  rw [Conjugates_symm_comp, Œ±Œ≤, Conjugates_symm_id]

/-- If `Œ±` is an isomorphism between left adjoints, then its conjugate transformation is an isomorphism.
The converse is given in `Conjugates_of_iso`.
-/
instance Conjugates_iso (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) [IsIso Œ±] :
    IsIso (Conjugates adj‚ÇÅ adj‚ÇÇ Œ±) :=
  ‚ü®‚ü®Conjugates adj‚ÇÇ adj‚ÇÅ (inv Œ±),
      ‚ü®Conjugates_comm _ _ (by simp), Conjugates_comm _ _ (by simp)‚ü©‚ü©‚ü©

/-- If `Œ±` is an isomorphism between right adjoints, then its conjugate transformation is an isomorphism.
The converse is given in `Conjugates_symm_of_iso`.
-/
instance Conjugates_symm_iso (Œ± : R‚ÇÅ ‚ü∂ R‚ÇÇ) [IsIso Œ±] :
    IsIso ((Conjugates adj‚ÇÅ adj‚ÇÇ).symm Œ±) :=
  ‚ü®‚ü®(Conjugates adj‚ÇÇ adj‚ÇÅ).symm (inv Œ±),
      ‚ü®Conjugates_symm_comm _ _ (by simp), Conjugates_symm_comm _ _ (by simp)‚ü©‚ü©‚ü©

/-- If `Œ±` is a natural transformation between left adjoints whose conjugate natural transformation is an isomorphism,
then `Œ±` is an isomorphism.
The converse is given in `Conjugate_iso`.
-/
theorem Conjugate_of_iso (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) [IsIso (Conjugates adj‚ÇÅ adj‚ÇÇ Œ±)] :
    IsIso Œ± := by
  suffices IsIso ((Conjugates adj‚ÇÅ adj‚ÇÇ).symm (Conjugates adj‚ÇÅ adj‚ÇÇ Œ±))
    by simpa using this
  infer_instance

/--
If `Œ±` is a natural transformation between right adjoints whose conjugate natural transformation is an isomorphism,
then `Œ±` is an isomorphism.
The converse is given in `Conjugates_symm_iso`.
-/
theorem Conjugates_symm_of_iso (Œ± : R‚ÇÅ ‚ü∂ R‚ÇÇ)
    [IsIso ((Conjugates adj‚ÇÅ adj‚ÇÇ).symm Œ±)] : IsIso Œ± := by
  suffices IsIso ((Conjugates adj‚ÇÅ adj‚ÇÇ) ((Conjugates adj‚ÇÅ adj‚ÇÇ).symm Œ±))
    by simpa using this
  infer_instance
end ConjugateComposition

section Self
variable {C : Type u‚ÇÅ} {D : Type u‚ÇÇ}
variable [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D]
variable {L‚ÇÅ L‚ÇÇ L‚ÇÉ : C ‚•§ D} {R‚ÇÅ R‚ÇÇ R‚ÇÉ : D ‚•§ C}
variable (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (adj‚ÇÉ : L‚ÇÉ ‚ä£ R‚ÇÉ)

/-- The old definition to be cut.-/
def transferNatTransSelf : (L‚ÇÇ ‚ü∂ L‚ÇÅ) ‚âÉ (R‚ÇÅ ‚ü∂ R‚ÇÇ) :=
  calc
    (L‚ÇÇ ‚ü∂ L‚ÇÅ) ‚âÉ _ := (Iso.homCongr L‚ÇÇ.leftUnitor L‚ÇÅ.rightUnitor).symm
    _ ‚âÉ _ := transferNatTrans adj‚ÇÅ adj‚ÇÇ
    _ ‚âÉ (R‚ÇÅ ‚ü∂ R‚ÇÇ) := R‚ÇÅ.rightUnitor.homCongr R‚ÇÇ.leftUnitor
#align category_theory.transfer_nat_trans_self CategoryTheory.transferNatTransSelf

theorem transferNatTransSelf_counit (f : L‚ÇÇ ‚ü∂ L‚ÇÅ) (X) :
    L‚ÇÇ.map ((transferNatTransSelf adj‚ÇÅ adj‚ÇÇ f).app _) ‚â´ adj‚ÇÇ.counit.app X =
      f.app _ ‚â´ adj‚ÇÅ.counit.app X := by
  dsimp [transferNatTransSelf]
  rw [id_comp, comp_id]
  have := transferNatTrans_counit adj‚ÇÅ adj‚ÇÇ (L‚ÇÇ.leftUnitor.hom ‚â´ f ‚â´ L‚ÇÅ.rightUnitor.inv) X
  dsimp at this
  rw [this]
  simp
#align category_theory.transfer_nat_trans_self_counit CategoryTheory.transferNatTransSelf_counit

theorem unit_transferNatTransSelf (f : L‚ÇÇ ‚ü∂ L‚ÇÅ) (X) :
    adj‚ÇÅ.unit.app _ ‚â´ (transferNatTransSelf adj‚ÇÅ adj‚ÇÇ f).app _ =
      adj‚ÇÇ.unit.app X ‚â´ R‚ÇÇ.map (f.app _) := by
  dsimp [transferNatTransSelf]
  rw [id_comp, comp_id]
  have := unit_transferNatTrans adj‚ÇÅ adj‚ÇÇ (L‚ÇÇ.leftUnitor.hom ‚â´ f ‚â´ L‚ÇÅ.rightUnitor.inv) X
  dsimp at this
  rw [this]
  simp
#align category_theory.unit_transfer_nat_trans_self CategoryTheory.unit_transferNatTransSelf

@[simp]
theorem transferNatTransSelf_id : transferNatTransSelf adj‚ÇÅ adj‚ÇÅ (ùüô _) = ùüô _ := by
  ext
  dsimp [transferNatTransSelf, transferNatTrans]
  simp
#align category_theory.transfer_nat_trans_self_id CategoryTheory.transferNatTransSelf_id

-- See library note [dsimp, simp]
@[simp]
theorem transferNatTransSelf_symm_id : (transferNatTransSelf adj‚ÇÅ adj‚ÇÅ).symm (ùüô _) = ùüô _ := by
  rw [Equiv.symm_apply_eq]
  simp
#align category_theory.transfer_nat_trans_self_symm_id CategoryTheory.transferNatTransSelf_symm_id

theorem transferNatTransSelf_comp (f g) :
    transferNatTransSelf adj‚ÇÅ adj‚ÇÇ f ‚â´ transferNatTransSelf adj‚ÇÇ adj‚ÇÉ g =
      transferNatTransSelf adj‚ÇÅ adj‚ÇÉ (g ‚â´ f) := by
  ext
  dsimp [transferNatTransSelf, transferNatTrans]
  simp only [id_comp, comp_id]
  rw [‚Üê adj‚ÇÉ.unit_naturality_assoc, ‚Üê R‚ÇÉ.map_comp, g.naturality_assoc, L‚ÇÇ.map_comp, assoc,
    adj‚ÇÇ.counit_naturality, adj‚ÇÇ.left_triangle_components_assoc, assoc]
#align category_theory.transfer_nat_trans_self_comp CategoryTheory.transferNatTransSelf_comp

theorem transferNatTransSelf_adjunction_id {L R : C ‚•§ C} (adj : L ‚ä£ R) (f : ùü≠ C ‚ü∂ L) (X : C) :
    (transferNatTransSelf adj Adjunction.id f).app X = f.app (R.obj X) ‚â´ adj.counit.app X := by
  dsimp [transferNatTransSelf, transferNatTrans, Adjunction.id]
  simp only [comp_id, id_comp]
#align category_theory.transfer_nat_trans_self_adjunction_id CategoryTheory.transferNatTransSelf_adjunction_id

theorem transferNatTransSelf_adjunction_id_symm {L R : C ‚•§ C} (adj : L ‚ä£ R) (g : R ‚ü∂ ùü≠ C) (X : C) :
    ((transferNatTransSelf adj Adjunction.id).symm g).app X = adj.unit.app X ‚â´ g.app (L.obj X) := by
  dsimp [transferNatTransSelf, transferNatTrans, Adjunction.id]
  simp only [comp_id, id_comp]
#align category_theory.transfer_nat_trans_self_adjunction_id_symm CategoryTheory.transferNatTransSelf_adjunction_id_symm

theorem transferNatTransSelf_symm_comp (f g) :
    (transferNatTransSelf adj‚ÇÇ adj‚ÇÅ).symm f ‚â´ (transferNatTransSelf adj‚ÇÉ adj‚ÇÇ).symm g =
      (transferNatTransSelf adj‚ÇÉ adj‚ÇÅ).symm (g ‚â´ f) := by
  rw [Equiv.eq_symm_apply, ‚Üê transferNatTransSelf_comp _ adj‚ÇÇ]
  simp
#align category_theory.transfer_nat_trans_self_symm_comp CategoryTheory.transferNatTransSelf_symm_comp

theorem transferNatTransSelf_comm {f g} (gf : g ‚â´ f = ùüô _) :
    transferNatTransSelf adj‚ÇÅ adj‚ÇÇ f ‚â´ transferNatTransSelf adj‚ÇÇ adj‚ÇÅ g = ùüô _ := by
  rw [transferNatTransSelf_comp, gf, transferNatTransSelf_id]
#align category_theory.transfer_nat_trans_self_comm CategoryTheory.transferNatTransSelf_comm

theorem transferNatTransSelf_symm_comm {f g} (gf : g ‚â´ f = ùüô _) :
    (transferNatTransSelf adj‚ÇÅ adj‚ÇÇ).symm f ‚â´ (transferNatTransSelf adj‚ÇÇ adj‚ÇÅ).symm g = ùüô _ := by
  rw [transferNatTransSelf_symm_comp, gf, transferNatTransSelf_symm_id]
#align category_theory.transfer_nat_trans_self_symm_comm CategoryTheory.transferNatTransSelf_symm_comm

/-- If `f` is an isomorphism, then the transferred natural transformation is an isomorphism.
The converse is given in `transferNatTransSelf_of_iso`.
-/
instance transferNatTransSelf_iso (f : L‚ÇÇ ‚ü∂ L‚ÇÅ) [IsIso f] :
    IsIso (transferNatTransSelf adj‚ÇÅ adj‚ÇÇ f) :=
  ‚ü®‚ü®transferNatTransSelf adj‚ÇÇ adj‚ÇÅ (inv f),
      ‚ü®transferNatTransSelf_comm _ _ (by simp), transferNatTransSelf_comm _ _ (by simp)‚ü©‚ü©‚ü©
#align category_theory.transfer_nat_trans_self_iso CategoryTheory.transferNatTransSelf_iso

/-- If `f` is an isomorphism, then the un-transferred natural transformation is an isomorphism.
The converse is given in `transferNatTransSelf_symm_of_iso`.
-/
instance transferNatTransSelf_symm_iso (f : R‚ÇÅ ‚ü∂ R‚ÇÇ) [IsIso f] :
    IsIso ((transferNatTransSelf adj‚ÇÅ adj‚ÇÇ).symm f) :=
  ‚ü®‚ü®(transferNatTransSelf adj‚ÇÇ adj‚ÇÅ).symm (inv f),
      ‚ü®transferNatTransSelf_symm_comm _ _ (by simp), transferNatTransSelf_symm_comm _ _ (by simp)‚ü©‚ü©‚ü©
#align category_theory.transfer_nat_trans_self_symm_iso CategoryTheory.transferNatTransSelf_symm_iso

/-- If `f` is a natural transformation whose transferred natural transformation is an isomorphism,
then `f` is an isomorphism.
The converse is given in `transferNatTransSelf_iso`.
-/
theorem transferNatTransSelf_of_iso (f : L‚ÇÇ ‚ü∂ L‚ÇÅ) [IsIso (transferNatTransSelf adj‚ÇÅ adj‚ÇÇ f)] :
    IsIso f := by
  suffices IsIso ((transferNatTransSelf adj‚ÇÅ adj‚ÇÇ).symm (transferNatTransSelf adj‚ÇÅ adj‚ÇÇ f))
    by simpa using this
  infer_instance
#align category_theory.transfer_nat_trans_self_of_iso CategoryTheory.transferNatTransSelf_of_iso

/--
If `f` is a natural transformation whose un-transferred natural transformation is an isomorphism,
then `f` is an isomorphism.
The converse is given in `transferNatTransSelf_symm_iso`.
-/
theorem transferNatTransSelf_symm_of_iso (f : R‚ÇÅ ‚ü∂ R‚ÇÇ)
    [IsIso ((transferNatTransSelf adj‚ÇÅ adj‚ÇÇ).symm f)] : IsIso f := by
  suffices IsIso ((transferNatTransSelf adj‚ÇÅ adj‚ÇÇ) ((transferNatTransSelf adj‚ÇÅ adj‚ÇÇ).symm f))
    by simpa using this
  infer_instance
#align category_theory.transfer_nat_trans_self_symm_of_iso CategoryTheory.transferNatTransSelf_symm_of_iso

end Self

end CategoryTheory
